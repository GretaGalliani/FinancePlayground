"""
FinanceDashboard module for visualizing financial data.

This module is responsible for creating an interactive dashboard to visualize 
financial data. It focuses solely on visualization and uses pre-processed
datasets generated by the Process class.
"""

import os
import polars as pl
from dash import dcc, html, Input, Output, dash_table
import plotly.graph_objects as go
import plotly.express as px
import dash_bootstrap_components as dbc
import dash
from datetime import datetime, timedelta


class FinanceDashboard:
    """
    A class for creating an interactive financial dashboard.

    This class focuses solely on visualization using pre-processed datasets
    generated by the Process class. It does not perform data processing
    operations itself.

    Attributes:
        config: Configuration object containing paths to datasets
        color_theme: Color scheme for the dashboard
    """

    def __init__(self, config):
        """
        Initialize the FinanceDashboard with configuration.

        Args:
            config: Configuration object containing paths to datasets
        """
        self.config = config

        # Get font configuration from config, or use defaults
        fonts = self.config.get(
            "fonts",
            {
                "title_font": "Montserrat",
                "body_font": "Open Sans",
                "font_url": "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
            },
        )

        # Initialize the Dash app with external stylesheets
        self.app = dash.Dash(
            __name__,
            external_stylesheets=[
                dbc.themes.BOOTSTRAP,
                "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css",
                fonts.get(
                    "font_url",
                    "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
                ),
            ],
        )

        # Get color palette from config or use default modern palette
        self.color_theme = config.get("color_palette", {})

        # Load the initial datasets
        self._load_datasets()

        # Set up the layout and callbacks
        self._setup_layout()
        self._setup_callbacks()

    #
    # Data Loading Methods
    #
    def _load_datasets(self):
        """Load all datasets required for visualization."""
        # Load monthly summary data
        self.df_monthly_summary = self._load_csv("monthly_summary_path")

        # Load expense and income breakdowns
        self.df_expenses_by_category = self._load_csv("expenses_by_category_path")
        self.df_expenses_stacked = self._load_csv("expenses_stacked_path")
        self.df_income_by_category = self._load_csv("income_by_category_path")
        self.df_income_stacked = self._load_csv("income_stacked_path")

        # Load savings data
        self.df_savings_metrics = self._load_csv("savings_metrics_path")
        self.df_savings_by_category = self._load_csv("savings_by_category_path")
        self.df_savings_allocation = self._load_csv("savings_allocation_path")

        # Load raw data for the transaction table
        self.df_processed_savings = self._load_csv("processed_savings_path")

        # Determine date range
        if self.df_monthly_summary is not None and len(self.df_monthly_summary) > 0:
            self.min_month = self.df_monthly_summary["Month"].min()
            self.max_month = self.df_monthly_summary["Month"].max()

            # Convert to date objects for the date picker
            self.min_date = datetime.strptime(f"{self.min_month}-01", "%Y-%m-%d")
            self.max_date = datetime.strptime(f"{self.max_month}-01", "%Y-%m-%d")
            # Add a month to the max date to include the full month
            self.max_date = (self.max_date.replace(day=28) + timedelta(days=4)).replace(
                day=1
            ) - timedelta(days=1)
        else:
            # Default to current month if no data
            today = datetime.now()
            self.min_date = today.replace(day=1) - timedelta(days=180)  # 6 months ago
            self.max_date = today
            self.min_month = self.min_date.strftime("%Y-%m")
            self.max_month = self.max_date.strftime("%Y-%m")

    def _load_csv(self, config_key):
        """
        Load a CSV file specified in the configuration.

        Args:
            config_key: Key in the configuration for the file path

        Returns:
            pl.DataFrame or None: DataFrame if the file exists, None otherwise
        """
        path = self.config.get(config_key)
        if not path or not os.path.exists(path):
            return None

        try:
            return pl.read_csv(path)
        except Exception as e:
            print(f"Error loading {path}: {e}")
            return None

    def _reload_dataset(self, config_key, start_month, end_month):
        """
        Reload a dataset and filter it by month range.

        Args:
            config_key: Key in the configuration for the file path
            start_month: Start month in 'YYYY-MM' format
            end_month: End month in 'YYYY-MM' format

        Returns:
            pl.DataFrame or None: Filtered DataFrame if the file exists, None otherwise
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Month" not in df.columns:
            return df

        return df.filter(
            (pl.col("Month") >= start_month) & (pl.col("Month") <= end_month)
        )

    def _reload_raw_dataset(self, config_key, start_date, end_date):
        """
        Reload a raw dataset and filter it by date range.

        Args:
            config_key: Key in the configuration for the file path
            start_date: Start date
            end_date: End date

        Returns:
            pl.DataFrame or None: Filtered DataFrame if the file exists, None otherwise
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Date" not in df.columns:
            return df

        # Convert string dates to datetime
        if df["Date"].dtype == pl.Utf8:
            df = df.with_columns(pl.col("Date").str.to_datetime().alias("Date"))

        return df.filter((pl.col("Date") >= start_date) & (pl.col("Date") <= end_date))

    #
    # Dashboard Setup Methods
    #
    def _setup_layout(self):
        """Set up the dashboard layout with the new date range default and consistent styling."""
        # Calculate default date range (January 1 of current year to today)
        today = datetime.now()
        end_date = self.max_date
        start_date = datetime(today.year, 1, 1)  # January 1 of current year

        # Make sure start_date is not before the earliest data
        if start_date < self.min_date:
            start_date = self.min_date

        # Get font configuration from config, or use defaults
        fonts = self.config.get(
            "fonts",
            {
                "title_font": "Montserrat",
                "body_font": "Open Sans",
                "font_url": "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
            },
        )

        title_font = fonts.get("title_font", "Montserrat")
        body_font = fonts.get("body_font", "Open Sans")

        # Apply styles directly to components instead of using html.Style
        body_style = {
            "backgroundColor": self.color_theme["background"],
            "fontFamily": f'"{body_font}", sans-serif',
        }

        heading_style = {
            "fontFamily": f'"{title_font}", sans-serif',
            "fontWeight": "600",
            "color": self.color_theme.get("headline", "#232323"),
        }

        self.app.layout = dbc.Container(
            [
                html.H1(
                    "Personal Finance Dashboard",
                    className="text-center mt-4 mb-4",
                    style=heading_style,
                ),
                dbc.Row(
                    [
                        dbc.Col(
                            [
                                dcc.DatePickerRange(
                                    id="date-range",
                                    min_date_allowed=self.min_date,
                                    max_date_allowed=self.max_date,
                                    start_date=start_date,
                                    end_date=end_date,
                                    style={"backgroundColor": "#ffffff"},
                                )
                            ],
                            width={"size": 6, "offset": 3},
                            className="text-center",
                        )
                    ],
                    className="mb-4",
                ),
                # Income & Expense cards placed above tabs
                html.Div(id="income-expense-cards", className="mb-4 mt-4"),
                # Tabs for different views
                dbc.Tabs(
                    [
                        dbc.Tab(
                            [
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="main-dashboard"),
                                            width=12,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="expense-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="income-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="stacked-expenses"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="stacked-income"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                            ],
                            label="Expenses & Income",
                            tab_id="expenses-tab",
                            style={"backgroundColor": self.color_theme["background"]},
                            tab_style={
                                "backgroundColor": self.color_theme["background"]
                            },
                        ),
                        dbc.Tab(
                            [
                                html.Div(id="savings-cards", className="mb-4 mt-4"),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="savings-overview"), width=8
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="savings-breakdown"), width=4
                                        ),
                                    ],
                                    className="mb-4",
                                ),
                                dcc.Graph(id="savings-allocation"),
                                html.H4(
                                    "Savings Transactions",
                                    className="mt-4 mb-3",
                                    style=heading_style,
                                ),
                                html.Div(id="savings-table"),
                            ],
                            label="Savings",
                            tab_id="savings-tab",
                            style={"backgroundColor": self.color_theme["background"]},
                            tab_style={
                                "backgroundColor": self.color_theme["background"]
                            },
                        ),
                    ],
                    id="dashboard-tabs",
                    active_tab="expenses-tab",
                    style={"backgroundColor": self.color_theme["background"]},
                ),
            ],
            fluid=True,
            style=body_style,
        )

    def _setup_callbacks(self):
        """Set up the dashboard callbacks with the new card structure."""

        @self.app.callback(
            [
                Output("income-expense-cards", "children"),
                Output("main-dashboard", "figure"),
                Output("expense-pie-chart", "figure"),
                Output("income-pie-chart", "figure"),
                Output("stacked-expenses", "figure"),
                Output("stacked-income", "figure"),
                Output("savings-cards", "children"),
                Output("savings-overview", "figure"),
                Output("savings-breakdown", "figure"),
                Output("savings-allocation", "figure"),
                Output("savings-table", "children"),
            ],
            [Input("date-range", "start_date"), Input("date-range", "end_date")],
        )
        def update_dashboard(start_date, end_date):
            # Convert input strings to datetime objects
            if start_date:
                # Handle ISO format dates with time component
                try:
                    if "T" in start_date:
                        start_date = datetime.strptime(start_date, "%Y-%m-%dT%H:%M:%S")
                    else:
                        start_date = datetime.strptime(start_date, "%Y-%m-%d")
                except ValueError:
                    # Fallback to just parsing the date part
                    start_date = datetime.strptime(start_date.split("T")[0], "%Y-%m-%d")

            if end_date:
                # Handle ISO format dates with time component
                try:
                    if "T" in end_date:
                        end_date = datetime.strptime(end_date, "%Y-%m-%dT%H:%M:%S")
                    else:
                        end_date = datetime.strptime(end_date, "%Y-%m-%d")
                except ValueError:
                    # Fallback to just parsing the date part
                    end_date = datetime.strptime(end_date.split("T")[0], "%Y-%m-%d")

            # Convert to month format for filtering monthly data
            start_month = start_date.strftime("%Y-%m")
            end_month = end_date.strftime("%Y-%m")

            # Reload and filter datasets
            filtered_monthly_summary = self._reload_dataset(
                "monthly_summary_path", start_month, end_month
            )
            filtered_expenses_stacked = self._reload_dataset(
                "expenses_stacked_path", start_month, end_month
            )
            filtered_income_stacked = self._reload_dataset(
                "income_stacked_path", start_month, end_month
            )
            filtered_savings_metrics = self._reload_dataset(
                "savings_metrics_path", start_month, end_month
            )

            # Reload raw savings data for the transaction table
            filtered_processed_savings = self._reload_raw_dataset(
                "processed_savings_path", start_date, end_date
            )

            # Create dashboard elements
            summary_cards = self._create_summary_cards(filtered_monthly_summary)
            fig_main_overview = self._create_monthly_overview(filtered_monthly_summary)
            fig_expense_pie_chart = self._create_expense_category_overview(
                filtered_monthly_summary
            )
            fig_income_pie_chart = self._create_income_category_overview(
                filtered_monthly_summary
            )
            fig_stacked_expenses = self._create_stacked_expenses(
                filtered_expenses_stacked
            )
            fig_stacked_income = self._create_stacked_income(filtered_income_stacked)

            # Create savings elements
            savings_cards = self._create_savings_summary_cards(filtered_savings_metrics)
            fig_savings = self._create_savings_figure(filtered_savings_metrics)
            fig_savings_breakdown = self._create_savings_breakdown_figure(
                self.df_savings_by_category
            )
            fig_savings_allocation = self._create_savings_allocation_figure(
                self.df_savings_allocation
            )
            savings_table = self._create_savings_table(filtered_processed_savings)

            return (
                summary_cards,  # Income-expense cards now above all tabs
                fig_main_overview,
                fig_expense_pie_chart,
                fig_income_pie_chart,
                fig_stacked_expenses,
                fig_stacked_income,
                savings_cards,
                fig_savings,
                fig_savings_breakdown,
                fig_savings_allocation,
                savings_table,
            )

    #
    # Summary Card Methods
    #

    def _create_summary_cards(self, df_monthly_summary):
        """
        Create summary cards for income, expenses, and balance with styling matching savings cards.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            return html.Div("No data available for the selected period.")

        total_income = df_monthly_summary["Income"].sum()
        total_expenses = df_monthly_summary["Expenses"].sum()
        total_balance = total_income - total_expenses

        # Use the same card styling and layout as savings cards
        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Income (€)", className="card-title"),
                                html.H4(
                                    f"{total_income:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["income"]},
                                ),
                                html.P(
                                    f"Based on {len(df_monthly_summary)} months",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["income"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Expenses (€)", className="card-title"),
                                html.H4(
                                    f"{total_expenses:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["expense"]},
                                ),
                                html.P(
                                    (
                                        f"Monthly average: {total_expenses / len(df_monthly_summary):.2f} €"
                                        if len(df_monthly_summary) > 0
                                        else ""
                                    ),
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["expense"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Balance (€)", className="card-title"),
                                html.H4(
                                    f"{total_balance:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["balance"]},
                                ),
                                html.P(
                                    f"Income - Expenses",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["balance"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    def _create_savings_summary_cards(self, df_savings_metrics):
        """
        Create summary cards for savings data with updated styling.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            return html.Div("No savings data available for the selected period.")

        # Get the latest month's metrics
        latest_month = df_savings_metrics["Month"].max()
        latest_metrics = df_savings_metrics.filter(pl.col("Month") == latest_month)

        if len(latest_metrics) == 0:
            return html.Div("No savings metrics available for the selected period.")

        total_savings = latest_metrics["TotalSavings"][0]
        total_allocated = latest_metrics["TotalAllocated"][0]
        total_spent = latest_metrics["TotalSpent"][0]

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Savings (€)", className="card-title"),
                                html.H4(
                                    f"{total_savings:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["total"]
                                    },
                                ),
                                html.P(
                                    f"As of {latest_month}",
                                    className="text-muted small",
                                ),
                                html.P(
                                    "All 'Risparmio' type categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["total"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Allocated Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_allocated:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"][
                                            "allocation"
                                        ]
                                    },
                                ),
                                html.P(
                                    "All 'Accantonamento' type categories (additions minus withdrawals)",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["allocation"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Spent Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_spent:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["spent"]
                                    },
                                ),
                                html.P(
                                    "Withdrawals from non-Accantonamento categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["spent"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    #
    # Income Visualization Methods
    #
    def _create_income_category_overview(self, df_monthly_summary):
        """
        Create an elegant donut chart for income categories.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if self.df_income_by_category is None or len(self.df_income_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Income Categories - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No income category data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a donut chart for income categories
        labels = self.df_income_by_category["Category"].to_list()
        values = self.df_income_by_category["Total"].to_list()

        # Use a distinct part of the color palette for income categories
        # to differentiate from expense categories
        colors = self.color_theme["categories"][8 : 8 + len(labels)]
        if len(colors) < len(labels):
            colors = colors * (len(labels) // len(colors) + 1)

        fig = go.Figure(
            data=[
                go.Pie(
                    labels=labels,
                    values=values,
                    hole=0.6,  # Set a larger hole for an elegant donut
                    textinfo="label+percent",
                    marker=dict(colors=colors),
                    textposition="outside",
                    textfont=dict(size=12),
                )
            ]
        )

        fig = self._update_figure_styling(fig, "Income Breakdown by Category")

        # Additional styling specific to donut charts
        fig.update_traces(
            hoverinfo="label+percent+value",
            hovertemplate="%{label}: %{value:.2f}€ (%{percent})<extra></extra>",
        )

        return fig

    def _create_income_category_breakdown(self, df_monthly_summary):
        """
        Create an income category breakdown figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if self.df_income_by_category is None or len(self.df_income_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Income Categories - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No income category data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a pie chart for income categories
        labels = self.df_income_by_category["Category"].to_list()
        values = self.df_income_by_category["Total"].to_list()

        fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=0.3)])

        fig.update_layout(
            title="Income Breakdown by Category",
            plot_bgcolor=self.color_theme["background"],
        )

        return fig

    def _create_stacked_expenses(self, df_expenses_stacked):
        """
        Create a stacked bar chart for expenses by category.

        Args:
            df_expenses_stacked: DataFrame with expenses by month and category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_expenses_stacked is None or len(df_expenses_stacked) == 0:
            fig = go.Figure()
            fig = self._update_figure_styling(
                fig, "Monthly Expense Breakdown - No Data Available"
            )
            fig.update_layout(
                yaxis=dict(title="Amount (€)"),
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_expenses_stacked["Category"].unique().to_list()
        colors = self.color_theme["categories"][: len(unique_categories)]
        if len(colors) < len(unique_categories):
            colors = colors * (len(unique_categories) // len(colors) + 1)

        fig = go.Figure()

        # Get all months for consistent x-axis
        all_months = sorted(df_expenses_stacked["Month"].unique().to_list())

        for category, color in zip(unique_categories, colors):
            filtered = df_expenses_stacked.filter(pl.col("Category") == category)

            # Create a dict for easy month lookup
            expenses_by_month = {
                row["Month"]: row["Expenses"] for row in filtered.rows(named=True)
            }

            # Create y-values for all months (with 0 for missing months)
            y_values = [expenses_by_month.get(month, 0) for month in all_months]

            fig.add_trace(
                go.Bar(
                    x=all_months,
                    y=y_values,
                    name=category,
                    marker_color=color,
                )
            )

        fig = self._update_figure_styling(fig, "Monthly Expense Breakdown")
        fig.update_layout(
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            showlegend=True,
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
            margin=dict(l=50, r=50, t=50, b=50),
            hovermode="x",
        )

        return fig

    def _create_stacked_income(self, df_income_stacked):
        """
        Create a stacked bar chart for income by category.

        Args:
            df_income_stacked: DataFrame with income by month and category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_income_stacked is None or len(df_income_stacked) == 0:
            fig = go.Figure()
            fig = self._update_figure_styling(
                fig, "Monthly Income Breakdown - No Data Available"
            )
            fig.update_layout(
                yaxis=dict(title="Amount (€)"),
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_income_stacked["Category"].unique().to_list()
        # Use a different part of the color palette for income categories
        colors = self.color_theme["categories"][8 : 8 + len(unique_categories)]
        if len(colors) < len(unique_categories):
            colors = colors * (len(unique_categories) // len(colors) + 1)

        fig = go.Figure()

        # Get all months for consistent x-axis
        all_months = sorted(df_income_stacked["Month"].unique().to_list())

        for category, color in zip(unique_categories, colors):
            filtered = df_income_stacked.filter(pl.col("Category") == category)

            # Create a dict for easy month lookup
            income_by_month = {
                row["Month"]: row["Income"] for row in filtered.rows(named=True)
            }

            # Create y-values for all months (with 0 for missing months)
            y_values = [income_by_month.get(month, 0) for month in all_months]

            fig.add_trace(
                go.Bar(
                    x=all_months,
                    y=y_values,
                    name=category,
                    marker_color=color,
                )
            )

        fig = self._update_figure_styling(fig, "Monthly Income Breakdown")
        fig.update_layout(
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            showlegend=True,
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
            margin=dict(l=50, r=50, t=50, b=50),
            hovermode="x",
        )

        return fig

    def _update_figure_styling(self, fig, title):
        """
        Apply consistent styling to all figures based on the color theme.

        Args:
            fig: Plotly figure to update
            title: Title for the figure

        Returns:
            go.Figure: Updated figure with consistent styling
        """
        fig.update_layout(
            title=title,
            plot_bgcolor=self.color_theme["background"],  # Background color
            paper_bgcolor=self.color_theme["background"],  # Background color
            font=dict(color="#232323"),  # Headline color for text
            yaxis=dict(
                titlefont=dict(color="#232323"),  # Headline color
                tickfont=dict(color="#222525"),  # Paragraph color
                gridcolor="rgba(35, 35, 35, 0.1)",  # Stroke color with opacity
            ),
            xaxis=dict(
                titlefont=dict(color="#232323"),  # Headline color
                tickfont=dict(color="#222525"),  # Paragraph color
                gridcolor="rgba(35, 35, 35, 0.1)",  # Stroke color with opacity
            ),
            legend=dict(
                font=dict(color="#222525"),  # Paragraph color
                bgcolor="#fffffe",  # Main illustration color
                bordercolor="#232323",  # Stroke color
            ),
            margin=dict(l=50, r=50, t=60, b=50),
        )

        return fig

    #
    # Expense Visualization Methods
    #
    def _create_expense_overview(self, df_monthly_summary):
        """
        Create an expense overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Expense Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a bar chart for expenses
        fig = go.Figure()
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=self.color_theme["expense"],
            )
        )

        fig.update_layout(
            title="Monthly Expense Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
        )

        return fig

    def _create_expense_category_overview(self, df_monthly_summary):
        """
        Create an elegant donut chart for expense categories.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if (
            self.df_expenses_by_category is None
            or len(self.df_expenses_by_category) == 0
        ):
            fig = go.Figure()
            fig.update_layout(
                title="Expense Categories - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No expense category data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a donut chart for expense categories
        labels = self.df_expenses_by_category["Category"].to_list()
        values = self.df_expenses_by_category["Total"].to_list()

        # Use a custom color palette for the expense categories
        colors = self.color_theme["categories"][: len(labels)]
        if len(colors) < len(labels):
            colors = colors * (len(labels) // len(colors) + 1)

        fig = go.Figure(
            data=[
                go.Pie(
                    labels=labels,
                    values=values,
                    hole=0.6,  # Set a larger hole for an elegant donut
                    textinfo="label+percent",
                    marker=dict(colors=colors),
                    textposition="outside",
                    textfont=dict(size=12),
                )
            ]
        )

        fig = self._update_figure_styling(fig, "Expense Breakdown by Category")

        # Additional styling specific to donut charts
        fig.update_traces(
            hoverinfo="label+percent+value",
            hovertemplate="%{label}: %{value:.2f}€ (%{percent})<extra></extra>",
        )

        return fig

    def _create_stacked_expenses(self, df_expenses_stacked):
        """
        Create a stacked bar chart for expenses by category.

        Args:
            df_expenses_stacked: DataFrame with expenses by month and category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_expenses_stacked is None or len(df_expenses_stacked) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Expense Breakdown - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_expenses_stacked["Category"].unique().to_list()
        colors = self.color_theme["categories"] * (
            len(unique_categories) // len(self.color_theme["categories"]) + 1
        )

        fig = go.Figure()

        for category, color in zip(unique_categories, colors):
            filtered = df_expenses_stacked.filter(pl.col("Category") == category)
            fig.add_trace(
                go.Bar(
                    x=filtered["Month"].to_list(),
                    y=filtered["Expenses"].to_list(),
                    name=category,
                    marker_color=color,
                )
            )

        fig.update_layout(
            title="Monthly Expense Breakdown",
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            showlegend=True,
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
            margin=dict(l=50, r=50, t=50, b=50),
            hovermode="x",
        )

        return fig

    #
    # Monthly Overview Visualization
    #
    def _create_monthly_overview(self, df_monthly_summary):
        """
        Create a monthly overview figure with income, expenses, and balance.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard

        Note:
            This method is now only used for the summary view, specific income and expense
            visualizations are created by their respective methods.
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add income bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Income"],
                name="Income",
                marker_color=self.color_theme["income"],
            )
        )

        # Add expense bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=self.color_theme["expense"],
            )
        )

        # Add balance line
        fig.add_trace(
            go.Scatter(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Balance"],
                name="Balance",
                line=dict(color=self.color_theme["balance"], width=3),
            )
        )

        fig.update_layout(
            title="Monthly Income, Expenses, and Balance Overview",
            barmode="group",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
        )

        return fig

    def _create_category_overview(self, df_monthly_summary):
        """
        Create a category overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        # This is a placeholder for now
        fig = go.Figure()
        fig.update_layout(
            title="Category Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
        )
        return fig

    #
    # Savings Visualization Methods
    #
    def _create_savings_figure(self, df_savings_metrics):
        """
        Create a figure showing savings trends.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add total savings line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSavings"].to_list(),
                name="Total Savings",
                line=dict(color=self.color_theme["savings"]["total"], width=4),
            )
        )

        # Add total allocations line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalAllocated"].to_list(),
                name="Total Allocations",
                line=dict(
                    color=self.color_theme["savings"]["allocation"],
                    width=3,
                    dash="dash",
                ),
            )
        )

        # Add total spent line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSpent"].to_list(),
                name="Total Spent",
                line=dict(
                    color=self.color_theme["savings"]["spent"], width=3, dash="dot"
                ),
            )
        )

        fig.update_layout(
            title="Savings Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
            legend=dict(
                orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
            ),
        )

        return fig

    def _create_savings_breakdown_figure(self, df_savings_by_category):
        """
        Create a pie chart showing the breakdown of savings by category.

        Args:
            df_savings_by_category: DataFrame with savings by category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_by_category is None or len(df_savings_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Breakdown - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Extract categories and values for the pie chart
        categories = df_savings_by_category["Category"].to_list()
        values = df_savings_by_category["Value"].to_list()

        # Create the pie chart
        fig = go.Figure()
        fig.add_trace(
            go.Pie(
                labels=categories,
                values=values,
                hole=0.3,
                textinfo="label+percent",
                insidetextorientation="radial",
            )
        )

        fig.update_layout(
            title="Savings Breakdown by Category (Risparmio Only)",
            plot_bgcolor=self.color_theme["background"],
        )

        return fig

    def _create_savings_allocation_figure(self, df_savings_allocation):
        """
        Create a figure comparing allocated vs spent savings.

        Args:
            df_savings_allocation: DataFrame with savings allocation data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_allocation is None or len(df_savings_allocation) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Allocation Status - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Get unique categories and types for plotting
        plot_categories = df_savings_allocation["Category"].unique().to_list()
        plot_types = df_savings_allocation["Type"].unique().to_list()

        # Build a figure with grouped bars
        fig = go.Figure()

        # Colors for different types
        colors = {
            "Saved": self.color_theme["income"],
            "Allocated": self.color_theme["savings"]["allocation"],
            "Spent from Savings": self.color_theme["expense"],
            "Spent from Allocations": "#FFA07A",  # Light salmon color
        }

        for allocation_type in plot_types:
            filtered_data = df_savings_allocation.filter(
                pl.col("Type") == allocation_type
            )

            # Create a dict of values by category
            values_by_category = {}
            for category in plot_categories:
                match = filtered_data.filter(pl.col("Category") == category)
                values_by_category[category] = (
                    match["Value"][0] if len(match) > 0 else 0
                )

            # Add bar trace
            fig.add_trace(
                go.Bar(
                    name=allocation_type,
                    x=list(values_by_category.keys()),
                    y=list(values_by_category.values()),
                    marker_color=colors.get(
                        allocation_type, "#808080"
                    ),  # Default gray if type not found
                )
            )

        # Update layout
        fig.update_layout(
            title="Allocation Status by Category",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            barmode="group",
            legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99),
        )

        return fig

    def _create_savings_table(self, df_savings):
        """
        Create a table of savings transactions.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period."
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value").map_elements(lambda x: f"€{x:.2f}").alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
            },
            style_header={
                "backgroundColor": "rgb(230, 230, 230)",
                "fontWeight": "bold",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{Type} = "Allocation"'},
                    "backgroundColor": "rgba(230, 126, 34, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Transfer"'},
                    "backgroundColor": "rgba(39, 174, 96, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Payment"'},
                    "backgroundColor": "rgba(231, 76, 60, 0.2)",
                },
            ],
            page_size=10,
        )

        return table

    #
    # Server Methods
    #
    def run_server(self, debug=False, port=8050):
        """
        Run the Dash server.

        Args:
            debug: Enable debug mode
            port: Port to run the server on
        """
        print(f"Dashboard will run at http://127.0.0.1:{port}/")
        self.app.run(debug=debug, port=port)
