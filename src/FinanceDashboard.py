"""
FinanceDashboard module for visualizing financial data.

This module is responsible for creating an interactive dashboard to visualize 
financial data. It focuses solely on visualization and uses pre-processed
datasets generated by the Process class.
"""

import os
import polars as pl
from dash import dcc, html, Input, Output, dash_table
import plotly.graph_objects as go
import plotly.express as px
import dash_bootstrap_components as dbc
import dash
from datetime import datetime, timedelta


class FinanceDashboard:
    """
    A class for creating an interactive financial dashboard.

    This class focuses solely on visualization using pre-processed datasets
    generated by the Process class. It does not perform data processing
    operations itself.

    Attributes:
        config: Configuration object containing paths to datasets
        color_theme: Color scheme for the dashboard
    """

    def __init__(self, config):
        """
        Initialize the FinanceDashboard with configuration.

        Args:
            config: Configuration object containing paths to datasets
        """
        self.config = config

        # Initialize the Dash app
        self.app = dash.Dash(
            __name__,
            external_stylesheets=[
                dbc.themes.BOOTSTRAP,
                "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css",
            ],
        )

        # Define color theme
        self.color_theme = {
            "income": "#2ecc71",  # Green for income
            "expense": "#e74c3c",  # Red for expenses
            "balance": "#3498db",  # Blue for balance/net
            "background": "#f8f9fa",  # Light background
            "savings": {
                "general": "#9b59b6",  # Purple for general savings
                "vacation": "#f1c40f",  # Yellow for vacation fund
                "therapy": "#1abc9c",  # Turquoise for therapy fund
                "misc": "#34495e",  # Dark blue for miscellaneous fund
                "total": "#8e44ad",  # Dark purple for total savings
                "allocation": "#e67e22",  # Orange for allocations
                "spent": "#27ae60",  # Green for spent
            },
            "categories": [
                "#e74c3c",
                "#3498db",
                "#9b59b6",
                "#f1c40f",
                "#2ecc71",
            ],  # Color palette for categories
        }

        # Load the initial datasets
        self._load_datasets()

        # Set up the layout and callbacks
        self._setup_layout()
        self._setup_callbacks()

    #
    # Data Loading Methods
    #
    def _load_datasets(self):
        """Load all datasets required for visualization."""
        # Load monthly summary data
        self.df_monthly_summary = self._load_csv("monthly_summary_path")

        # Load expense and income breakdowns
        self.df_expenses_by_category = self._load_csv("expenses_by_category_path")
        self.df_expenses_stacked = self._load_csv("expenses_stacked_path")
        self.df_income_by_category = self._load_csv("income_by_category_path")
        self.df_income_stacked = self._load_csv("income_stacked_path")

        # Load savings data
        self.df_savings_metrics = self._load_csv("savings_metrics_path")
        self.df_savings_by_category = self._load_csv("savings_by_category_path")
        self.df_savings_allocation = self._load_csv("savings_allocation_path")

        # Load raw data for the transaction table
        self.df_processed_savings = self._load_csv("processed_savings_path")

        # Determine date range
        if self.df_monthly_summary is not None and len(self.df_monthly_summary) > 0:
            self.min_month = self.df_monthly_summary["Month"].min()
            self.max_month = self.df_monthly_summary["Month"].max()

            # Convert to date objects for the date picker
            self.min_date = datetime.strptime(f"{self.min_month}-01", "%Y-%m-%d")
            self.max_date = datetime.strptime(f"{self.max_month}-01", "%Y-%m-%d")
            # Add a month to the max date to include the full month
            self.max_date = (self.max_date.replace(day=28) + timedelta(days=4)).replace(
                day=1
            ) - timedelta(days=1)
        else:
            # Default to current month if no data
            today = datetime.now()
            self.min_date = today.replace(day=1) - timedelta(days=180)  # 6 months ago
            self.max_date = today
            self.min_month = self.min_date.strftime("%Y-%m")
            self.max_month = self.max_date.strftime("%Y-%m")

    def _load_csv(self, config_key):
        """
        Load a CSV file specified in the configuration.

        Args:
            config_key: Key in the configuration for the file path

        Returns:
            pl.DataFrame or None: DataFrame if the file exists, None otherwise
        """
        path = self.config.get(config_key)
        if not path or not os.path.exists(path):
            return None

        try:
            return pl.read_csv(path)
        except Exception as e:
            print(f"Error loading {path}: {e}")
            return None

    def _reload_dataset(self, config_key, start_month, end_month):
        """
        Reload a dataset and filter it by month range.

        Args:
            config_key: Key in the configuration for the file path
            start_month: Start month in 'YYYY-MM' format
            end_month: End month in 'YYYY-MM' format

        Returns:
            pl.DataFrame or None: Filtered DataFrame if the file exists, None otherwise
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Month" not in df.columns:
            return df

        return df.filter(
            (pl.col("Month") >= start_month) & (pl.col("Month") <= end_month)
        )

    def _reload_raw_dataset(self, config_key, start_date, end_date):
        """
        Reload a raw dataset and filter it by date range.

        Args:
            config_key: Key in the configuration for the file path
            start_date: Start date
            end_date: End date

        Returns:
            pl.DataFrame or None: Filtered DataFrame if the file exists, None otherwise
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Date" not in df.columns:
            return df

        # Convert string dates to datetime
        if df["Date"].dtype == pl.Utf8:
            df = df.with_columns(pl.col("Date").str.to_datetime().alias("Date"))

        return df.filter((pl.col("Date") >= start_date) & (pl.col("Date") <= end_date))

    #
    # Dashboard Setup Methods
    #
    def _setup_layout(self):
        """Set up the dashboard layout."""
        # Calculate default date range (6 months before today)
        end_date = self.max_date
        start_date = max(self.min_date, end_date - timedelta(days=180))  # Last 6 months

        self.app.layout = dbc.Container(
            [
                html.H1(
                    "Personal Finance Dashboard", className="text-center mt-4 mb-4"
                ),
                dbc.Row(
                    [
                        dbc.Col(
                            [
                                dcc.DatePickerRange(
                                    id="date-range",
                                    min_date_allowed=self.min_date,
                                    max_date_allowed=self.max_date,
                                    start_date=start_date,
                                    end_date=end_date,
                                )
                            ],
                            width={"size": 6, "offset": 3},
                            className="text-center",
                        )
                    ],
                    className="mb-4",
                ),
                html.Div(id="summary-cards"),
                # Tabs for different views
                dbc.Tabs(
                    [
                        dbc.Tab(
                            [
                                dcc.Graph(id="main-dashboard"),
                                dcc.Graph(id="category-dashboard"),
                                dcc.Graph(id="stacked-expenses"),
                            ],
                            label="Expenses",
                            tab_id="expenses-tab",
                        ),
                        dbc.Tab(
                            [
                                dcc.Graph(id="income-overview"),
                                dcc.Graph(id="stacked-income"),
                                dcc.Graph(id="income-categories"),
                            ],
                            label="Income",
                            tab_id="income-tab",
                        ),
                        dbc.Tab(
                            [
                                html.Div(id="savings-cards", className="mb-4 mt-4"),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="savings-overview"), width=8
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="savings-breakdown"), width=4
                                        ),
                                    ],
                                    className="mb-4",
                                ),
                                dcc.Graph(id="savings-allocation"),
                                html.H4("Savings Transactions", className="mt-4 mb-3"),
                                html.Div(id="savings-table"),
                            ],
                            label="Savings",
                            tab_id="savings-tab",
                        ),
                    ],
                    id="dashboard-tabs",
                    active_tab="expenses-tab",
                ),
            ],
            fluid=True,
        )

    def _setup_callbacks(self):
        """Set up the dashboard callbacks."""

        @self.app.callback(
            [
                Output("summary-cards", "children"),
                Output("main-dashboard", "figure"),
                Output("category-dashboard", "figure"),
                Output("stacked-expenses", "figure"),
                Output("income-overview", "figure"),
                Output("stacked-income", "figure"),
                Output("income-categories", "figure"),
                Output("savings-cards", "children"),
                Output("savings-overview", "figure"),
                Output("savings-breakdown", "figure"),
                Output("savings-allocation", "figure"),
                Output("savings-table", "children"),
            ],
            [Input("date-range", "start_date"), Input("date-range", "end_date")],
        )
        def update_dashboard(start_date, end_date):
            # Convert input strings to datetime objects
            if start_date:
                # Handle ISO format dates with time component
                try:
                    if "T" in start_date:
                        start_date = datetime.strptime(start_date, "%Y-%m-%dT%H:%M:%S")
                    else:
                        start_date = datetime.strptime(start_date, "%Y-%m-%d")
                except ValueError:
                    # Fallback to just parsing the date part
                    start_date = datetime.strptime(start_date.split("T")[0], "%Y-%m-%d")

            if end_date:
                # Handle ISO format dates with time component
                try:
                    if "T" in end_date:
                        end_date = datetime.strptime(end_date, "%Y-%m-%dT%H:%M:%S")
                    else:
                        end_date = datetime.strptime(end_date, "%Y-%m-%d")
                except ValueError:
                    # Fallback to just parsing the date part
                    end_date = datetime.strptime(end_date.split("T")[0], "%Y-%m-%d")

            # Convert to month format for filtering monthly data
            start_month = start_date.strftime("%Y-%m")
            end_month = end_date.strftime("%Y-%m")

            # Reload and filter datasets
            filtered_monthly_summary = self._reload_dataset(
                "monthly_summary_path", start_month, end_month
            )
            filtered_expenses_stacked = self._reload_dataset(
                "expenses_stacked_path", start_month, end_month
            )
            filtered_income_stacked = self._reload_dataset(
                "income_stacked_path", start_month, end_month
            )
            filtered_savings_metrics = self._reload_dataset(
                "savings_metrics_path", start_month, end_month
            )

            # Reload raw savings data for the transaction table
            filtered_processed_savings = self._reload_raw_dataset(
                "processed_savings_path", start_date, end_date
            )

            # Create dashboard elements
            summary_cards = self._create_summary_cards(filtered_monthly_summary)
            fig_main_overview = self._create_monthly_overview(filtered_monthly_summary)
            fig_expense_categories = self._create_expense_category_overview(
                filtered_monthly_summary
            )
            fig_expenses = self._create_stacked_expenses(filtered_expenses_stacked)

            # Create income elements
            fig_income_overview = self._create_income_overview(filtered_monthly_summary)
            fig_income = self._create_stacked_income(filtered_income_stacked)
            fig_income_categories = self._create_income_category_breakdown(
                filtered_monthly_summary
            )

            # Create savings elements
            savings_cards = self._create_savings_summary_cards(filtered_savings_metrics)
            fig_savings = self._create_savings_figure(filtered_savings_metrics)
            fig_savings_breakdown = self._create_savings_breakdown_figure(
                self.df_savings_by_category
            )
            fig_savings_allocation = self._create_savings_allocation_figure(
                self.df_savings_allocation
            )
            savings_table = self._create_savings_table(filtered_processed_savings)

            return (
                summary_cards,
                fig_main_overview,
                fig_expense_categories,
                fig_expenses,
                fig_income_overview,
                fig_income,
                fig_income_categories,
                savings_cards,
                fig_savings,
                fig_savings_breakdown,
                fig_savings_allocation,
                savings_table,
            )

    #
    # Summary Card Methods
    #
    def _create_summary_cards(self, df_monthly_summary):
        """
        Create summary cards for income, expenses, and balance.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            return html.Div("No data available for the selected period.")

        total_income = df_monthly_summary["Income"].sum()
        total_expenses = df_monthly_summary["Expenses"].sum()
        total_balance = total_income - total_expenses

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Income (€)", className="card-title"),
                                html.H4(
                                    f"{total_income:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["income"]},
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    )
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Expenses (€)", className="card-title"),
                                html.H4(
                                    f"{total_expenses:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["expense"]},
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    )
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Balance (€)", className="card-title"),
                                html.H4(
                                    f"{total_balance:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["balance"]},
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    )
                ),
            ],
            className="mb-4",
        )

        return cards

    def _create_savings_summary_cards(self, df_savings_metrics):
        """
        Create summary cards for savings data.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            return html.Div("No savings data available for the selected period.")

        # Get the latest month's metrics
        latest_month = df_savings_metrics["Month"].max()
        latest_metrics = df_savings_metrics.filter(pl.col("Month") == latest_month)

        if len(latest_metrics) == 0:
            return html.Div("No savings metrics available for the selected period.")

        total_savings = latest_metrics["TotalSavings"][0]
        total_allocated = latest_metrics["TotalAllocated"][0]
        total_spent = latest_metrics["TotalSpent"][0]

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Savings (€)", className="card-title"),
                                html.H4(
                                    f"{total_savings:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["total"]
                                    },
                                ),
                                html.P(f"As of {latest_month}", className="text-muted"),
                                html.P(
                                    "All 'Risparmio' type categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Allocated Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_allocated:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"][
                                            "allocation"
                                        ]
                                    },
                                ),
                                html.P(
                                    "All 'Accantonamento' type categories (additions minus withdrawals)",
                                    className="text-muted",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Spent Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_spent:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["spent"]
                                    },
                                ),
                                html.P(
                                    "Withdrawals from non-Accantonamento categories",
                                    className="text-muted",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    #
    # Income Visualization Methods
    #
    def _create_income_overview(self, df_monthly_summary):
        """
        Create an income overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Income Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a bar chart for income
        fig = go.Figure()
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Income"],
                name="Income",
                marker_color=self.color_theme["income"],
            )
        )

        fig.update_layout(
            title="Monthly Income Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
        )

        return fig

    def _create_income_category_breakdown(self, df_monthly_summary):
        """
        Create an income category breakdown figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if self.df_income_by_category is None or len(self.df_income_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Income Categories - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No income category data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a pie chart for income categories
        labels = self.df_income_by_category["Category"].to_list()
        values = self.df_income_by_category["Total"].to_list()

        fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=0.3)])

        fig.update_layout(
            title="Income Breakdown by Category",
            plot_bgcolor=self.color_theme["background"],
        )

        return fig

    def _create_stacked_income(self, df_income_stacked):
        """
        Create a stacked bar chart for income by category.

        Args:
            df_income_stacked: DataFrame with income by month and category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_income_stacked is None or len(df_income_stacked) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Income Breakdown - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_income_stacked["Category"].unique().to_list()
        colors = self.color_theme["categories"] * (
            len(unique_categories) // len(self.color_theme["categories"]) + 1
        )

        fig = go.Figure()

        for category, color in zip(unique_categories, colors):
            filtered = df_income_stacked.filter(pl.col("Category") == category)
            fig.add_trace(
                go.Bar(
                    x=filtered["Month"].to_list(),
                    y=filtered["Income"].to_list(),
                    name=category,
                    marker_color=color,
                )
            )

        fig.update_layout(
            title="Monthly Income Breakdown",
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            showlegend=True,
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
            margin=dict(l=50, r=50, t=50, b=50),
            hovermode="x",
        )

        return fig

    #
    # Expense Visualization Methods
    #
    def _create_expense_overview(self, df_monthly_summary):
        """
        Create an expense overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Expense Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a bar chart for expenses
        fig = go.Figure()
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=self.color_theme["expense"],
            )
        )

        fig.update_layout(
            title="Monthly Expense Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
        )

        return fig

    def _create_expense_category_overview(self, df_monthly_summary):
        """
        Create an expense category overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if (
            self.df_expenses_by_category is None
            or len(self.df_expenses_by_category) == 0
        ):
            fig = go.Figure()
            fig.update_layout(
                title="Expense Categories - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No expense category data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a pie chart for expense categories
        labels = self.df_expenses_by_category["Category"].to_list()
        values = self.df_expenses_by_category["Total"].to_list()

        fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=0.3)])

        fig.update_layout(
            title="Expense Breakdown by Category",
            plot_bgcolor=self.color_theme["background"],
        )

        return fig

    def _create_stacked_expenses(self, df_expenses_stacked):
        """
        Create a stacked bar chart for expenses by category.

        Args:
            df_expenses_stacked: DataFrame with expenses by month and category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_expenses_stacked is None or len(df_expenses_stacked) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Expense Breakdown - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_expenses_stacked["Category"].unique().to_list()
        colors = self.color_theme["categories"] * (
            len(unique_categories) // len(self.color_theme["categories"]) + 1
        )

        fig = go.Figure()

        for category, color in zip(unique_categories, colors):
            filtered = df_expenses_stacked.filter(pl.col("Category") == category)
            fig.add_trace(
                go.Bar(
                    x=filtered["Month"].to_list(),
                    y=filtered["Expenses"].to_list(),
                    name=category,
                    marker_color=color,
                )
            )

        fig.update_layout(
            title="Monthly Expense Breakdown",
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            showlegend=True,
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
            margin=dict(l=50, r=50, t=50, b=50),
            hovermode="x",
        )

        return fig

    #
    # Monthly Overview Visualization
    #
    def _create_monthly_overview(self, df_monthly_summary):
        """
        Create a monthly overview figure with income, expenses, and balance.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard

        Note:
            This method is now only used for the summary view, specific income and expense
            visualizations are created by their respective methods.
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add income bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Income"],
                name="Income",
                marker_color=self.color_theme["income"],
            )
        )

        # Add expense bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=self.color_theme["expense"],
            )
        )

        # Add balance line
        fig.add_trace(
            go.Scatter(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Balance"],
                name="Balance",
                line=dict(color=self.color_theme["balance"], width=3),
            )
        )

        fig.update_layout(
            title="Monthly Income, Expenses, and Balance Overview",
            barmode="group",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
        )

        return fig

    def _create_category_overview(self, df_monthly_summary):
        """
        Create a category overview figure.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        # This is a placeholder for now
        fig = go.Figure()
        fig.update_layout(
            title="Category Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
        )
        return fig

    #
    # Savings Visualization Methods
    #
    def _create_savings_figure(self, df_savings_metrics):
        """
        Create a figure showing savings trends.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add total savings line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSavings"].to_list(),
                name="Total Savings",
                line=dict(color=self.color_theme["savings"]["total"], width=4),
            )
        )

        # Add total allocations line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalAllocated"].to_list(),
                name="Total Allocations",
                line=dict(
                    color=self.color_theme["savings"]["allocation"],
                    width=3,
                    dash="dash",
                ),
            )
        )

        # Add total spent line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSpent"].to_list(),
                name="Total Spent",
                line=dict(
                    color=self.color_theme["savings"]["spent"], width=3, dash="dot"
                ),
            )
        )

        fig.update_layout(
            title="Savings Overview",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            hovermode="x",
            legend=dict(
                orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
            ),
        )

        return fig

    def _create_savings_breakdown_figure(self, df_savings_by_category):
        """
        Create a pie chart showing the breakdown of savings by category.

        Args:
            df_savings_by_category: DataFrame with savings by category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_by_category is None or len(df_savings_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Breakdown - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Extract categories and values for the pie chart
        categories = df_savings_by_category["Category"].to_list()
        values = df_savings_by_category["Value"].to_list()

        # Create the pie chart
        fig = go.Figure()
        fig.add_trace(
            go.Pie(
                labels=categories,
                values=values,
                hole=0.3,
                textinfo="label+percent",
                insidetextorientation="radial",
            )
        )

        fig.update_layout(
            title="Savings Breakdown by Category (Risparmio Only)",
            plot_bgcolor=self.color_theme["background"],
        )

        return fig

    def _create_savings_allocation_figure(self, df_savings_allocation):
        """
        Create a figure comparing allocated vs spent savings.

        Args:
            df_savings_allocation: DataFrame with savings allocation data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_allocation is None or len(df_savings_allocation) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Allocation Status - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Get unique categories and types for plotting
        plot_categories = df_savings_allocation["Category"].unique().to_list()
        plot_types = df_savings_allocation["Type"].unique().to_list()

        # Build a figure with grouped bars
        fig = go.Figure()

        # Colors for different types
        colors = {
            "Saved": self.color_theme["income"],
            "Allocated": self.color_theme["savings"]["allocation"],
            "Spent from Savings": self.color_theme["expense"],
            "Spent from Allocations": "#FFA07A",  # Light salmon color
        }

        for allocation_type in plot_types:
            filtered_data = df_savings_allocation.filter(
                pl.col("Type") == allocation_type
            )

            # Create a dict of values by category
            values_by_category = {}
            for category in plot_categories:
                match = filtered_data.filter(pl.col("Category") == category)
                values_by_category[category] = (
                    match["Value"][0] if len(match) > 0 else 0
                )

            # Add bar trace
            fig.add_trace(
                go.Bar(
                    name=allocation_type,
                    x=list(values_by_category.keys()),
                    y=list(values_by_category.values()),
                    marker_color=colors.get(
                        allocation_type, "#808080"
                    ),  # Default gray if type not found
                )
            )

        # Update layout
        fig.update_layout(
            title="Allocation Status by Category",
            yaxis=dict(title="Amount (€)"),
            plot_bgcolor=self.color_theme["background"],
            barmode="group",
            legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99),
        )

        return fig

    def _create_savings_table(self, df_savings):
        """
        Create a table of savings transactions.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period."
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value").map_elements(lambda x: f"€{x:.2f}").alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
            },
            style_header={
                "backgroundColor": "rgb(230, 230, 230)",
                "fontWeight": "bold",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{Type} = "Allocation"'},
                    "backgroundColor": "rgba(230, 126, 34, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Transfer"'},
                    "backgroundColor": "rgba(39, 174, 96, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Payment"'},
                    "backgroundColor": "rgba(231, 76, 60, 0.2)",
                },
            ],
            page_size=10,
        )

        return table

    #
    # Server Methods
    #
    def run_server(self, debug=False, port=8050):
        """
        Run the Dash server.

        Args:
            debug: Enable debug mode
            port: Port to run the server on
        """
        print(f"Dashboard will run at http://127.0.0.1:{port}/")
        self.app.run(debug=debug, port=port)
