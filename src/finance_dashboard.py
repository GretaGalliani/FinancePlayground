#!/filepath: src/finance_dashboard.py
"""
FinanceDashboard module for visualizing financial data.

This module is responsible for creating an interactive dashboard to visualize
financial data. It focuses solely on visualization and uses pre-processed
datasets generated by the Process class.
"""

import logging
import os
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, Union, cast

import dash
import dash_bootstrap_components as dbc
import plotly.graph_objects as go
import polars as pl
from dash import Input, Output, dash_table, dcc, html

if TYPE_CHECKING:
    from config import Config


@dataclass
class DashboardConfig:
    """Configuration container for the dashboard."""

    color_theme: Dict[str, Any]
    chart_styling: Dict[str, Any] = field(default_factory=dict)
    fonts: Dict[str, str] = field(default_factory=dict)
    date_display_format: str = "DD/MM/YYYY"


class DatasetLoader:
    """
    Handles loading and filtering datasets for the dashboard.

    This class is responsible for loading CSV files specified in configuration
    and providing filtered views of the data based on date ranges.
    """

    def __init__(self, config: Any, logger: logging.Logger):
        """
        Initialize the dataset loader.

        Args:
            config: Configuration object containing file paths
            logger: Logger instance for logging data operations
        """
        self.config = config
        self.logger = logger.getChild("DatasetLoader")
        self.datasets: Dict[str, Optional[pl.DataFrame]] = {}
        self.min_date: datetime = datetime.now()
        self.max_date: datetime = datetime.now()
        self.min_month: str = ""
        self.max_month: str = ""

    def load_all_datasets(self) -> None:
        """Load all datasets required for visualization and determine date range."""
        # Load monthly summary data
        self.datasets["monthly_summary"] = self._load_csv("monthly_summary_path")

        # Load expense and income breakdowns
        self.datasets["expenses_by_category"] = self._load_csv(
            "expenses_by_category_path"
        )
        self.datasets["expenses_stacked"] = self._load_csv("expenses_stacked_path")
        self.datasets["income_by_category"] = self._load_csv("income_by_category_path")
        self.datasets["income_stacked"] = self._load_csv("income_stacked_path")

        # Load savings data
        self.datasets["savings_metrics"] = self._load_csv("savings_metrics_path")
        self.datasets["savings_by_category"] = self._load_csv(
            "savings_by_category_path"
        )
        self.datasets["savings_allocation"] = self._load_csv("savings_allocation_path")
        self.datasets["processed_savings"] = self._load_csv("processed_savings_path")

        # Determine date range
        self._determine_date_range()

    def _load_csv(self, config_key: str) -> Optional[pl.DataFrame]:
        """
        Load a CSV file specified in the configuration.

        Args:
            config_key: Key in the configuration for the file path

        Returns:
            pl.DataFrame or None: DataFrame if the file exists, None otherwise
        """
        path = self.config.get(config_key)
        if not path or not os.path.exists(path):
            return None

        try:
            return pl.read_csv(path)
        except Exception as e:
            self.logger.error(f"Error loading {path}: {str(e)}")
            return None

    def _determine_date_range(self) -> None:
        """Determine the min and max dates from the loaded data."""
        monthly_summary = self.datasets["monthly_summary"]

        if monthly_summary is not None and len(monthly_summary) > 0:
            self.min_month = monthly_summary["Month"].min()
            self.max_month = monthly_summary["Month"].max()

            # Convert to date objects for the date picker
            self.min_date = datetime.strptime(f"{self.min_month}-01", "%Y-%m-%d")
            self.max_date = datetime.strptime(f"{self.max_month}-01", "%Y-%m-%d")
            # Add a month to the max date to include the full month
            self.max_date = (self.max_date.replace(day=28) + timedelta(days=4)).replace(
                day=1
            ) - timedelta(days=1)
        else:
            # Default to current month if no data
            today = datetime.now()
            self.min_date = today.replace(day=1) - timedelta(days=180)  # 6 months ago
            self.max_date = today
            self.min_month = self.min_date.strftime("%Y-%m")
            self.max_month = self.max_date.strftime("%Y-%m")

    def filter_monthly_dataset(
        self, config_key: str, start_month: str, end_month: str
    ) -> Optional[pl.DataFrame]:
        """
        Filter a dataset by month range.

        Args:
            config_key: Key in the configuration for the file path
            start_month: Start month in 'YYYY-MM' format
            end_month: End month in 'YYYY-MM' format

        Returns:
            pl.DataFrame or None: Filtered DataFrame
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Month" not in df.columns:
            return df

        return df.filter(
            (pl.col("Month") >= start_month) & (pl.col("Month") <= end_month)
        )

    def filter_daily_dataset(
        self, config_key: str, start_date: datetime, end_date: datetime
    ) -> Optional[pl.DataFrame]:
        """
        Filter a dataset by date range.

        Args:
            config_key: Key in the configuration for the file path
            start_date: Start date
            end_date: End date

        Returns:
            pl.DataFrame or None: Filtered DataFrame
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Date" not in df.columns:
            return df

        # Convert string dates to datetime if needed
        if df["Date"].dtype == pl.Utf8:
            df = df.with_columns(pl.col("Date").str.to_datetime().alias("Date"))

        return df.filter((pl.col("Date") >= start_date) & (pl.col("Date") <= end_date))

    def get_dataset(self, name: str) -> Optional[pl.DataFrame]:
        """
        Get a loaded dataset by name.

        Args:
            name: Name of the dataset

        Returns:
            pl.DataFrame or None: The requested dataset
        """
        return self.datasets.get(name)


class CardCreator:
    """
    Creates summary cards for the dashboard.

    This class is responsible for generating summary cards for income,
    expenses, balance, and savings metrics.
    """

    def __init__(self, color_theme: Dict[str, Any]):
        """
        Initialize the card creator.

        Args:
            color_theme: Color theme for the cards
        """
        self.color_theme = color_theme

    def create_summary_cards(self, df_monthly_summary: Optional[pl.DataFrame]) -> Any:
        """
        Create summary cards for income, expenses, and balance.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            return html.Div(
                "No data available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        total_income = df_monthly_summary["Income"].sum()
        total_expenses = df_monthly_summary["Expenses"].sum()
        total_balance = total_income - total_expenses

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Income (€)", className="card-title"),
                                html.H4(
                                    f"{total_income:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["income"]},
                                ),
                                html.P(
                                    f"Based on {len(df_monthly_summary)} months",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["income"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Expenses (€)", className="card-title"),
                                html.H4(
                                    f"{total_expenses:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["expense"]},
                                ),
                                html.P(
                                    (
                                        f"Monthly average: {total_expenses / len(df_monthly_summary):.2f} €"
                                        if len(df_monthly_summary) > 0
                                        else ""
                                    ),
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["expense"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Balance (€)", className="card-title"),
                                html.H4(
                                    f"{total_balance:.2f}",
                                    className="card-text",
                                    style={"color": self.color_theme["balance"]},
                                ),
                                html.P(
                                    f"Income - Expenses",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["balance"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    def create_savings_cards(self, df_savings_metrics: Optional[pl.DataFrame]) -> Any:
        """
        Create summary cards for savings data.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            return html.Div(
                "No savings data available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        # Get the latest month's metrics
        latest_month = df_savings_metrics["Month"].max()
        latest_metrics = df_savings_metrics.filter(pl.col("Month") == latest_month)

        if len(latest_metrics) == 0:
            return html.Div(
                "No savings metrics available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        total_savings = latest_metrics["TotalSavings"][0]
        total_allocated = latest_metrics["TotalAllocated"][0]
        total_spent = latest_metrics["TotalSpent"][0]

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Savings (€)", className="card-title"),
                                html.H4(
                                    f"{total_savings:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["total"]
                                    },
                                ),
                                html.P(
                                    f"As of {latest_month}",
                                    className="text-muted small",
                                ),
                                html.P(
                                    "All 'Risparmio' type categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["total"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Allocated Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_allocated:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"][
                                            "allocation"
                                        ]
                                    },
                                ),
                                html.P(
                                    "All 'Accantonamento' type categories (additions minus withdrawals)",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["allocation"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Spent Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_spent:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["spent"]
                                    },
                                ),
                                html.P(
                                    "Withdrawals from non-Accantonamento categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["spent"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    def create_savings_table(self, df_savings: Optional[pl.DataFrame]) -> Any:
        """
        Create a table of savings transactions with white background.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value")
                .map_elements(lambda x: f"€{x:.2f}", return_dtype=pl.Utf8)
                .alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table with white background and purple accents
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
                "backgroundColor": "white",
            },
            style_header={
                "backgroundColor": "rgba(108, 59, 206, 0.1)",  # Light purple background
                "fontWeight": "bold",
                "color": self.color_theme.get("headline", "#6C3BCE"),
                "borderBottom": f"2px solid {self.color_theme.get('headline', '#6C3BCE')}",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{CategoryType} = "Accantonamento"'},
                    "backgroundColor": "rgba(7, 128, 128, 0.05)",  # Very light teal
                    "borderLeft": f"3px solid {self.color_theme['income']}",
                },
                {
                    "if": {"filter_query": "{Value} < 0"},
                    "backgroundColor": "rgba(244, 93, 72, 0.05)",  # Very light coral
                    "borderLeft": f"3px solid {self.color_theme['expense']}",
                },
            ],
            page_size=10,
        )

        return table


class DateParser:
    """
    Handles parsing and standardization of dates in various formats.

    This class provides utilities for parsing dates from strings in
    multiple formats and handling edge cases.
    """

    @staticmethod
    def parse_date(date_string: Union[str, datetime]) -> datetime:
        """
        Parse date string in multiple formats to handle different possible inputs.

        Args:
            date_string: String or datetime representation of date to parse

        Returns:
            datetime: Parsed datetime object

        Raises:
            ValueError: If the date cannot be parsed
        """
        if isinstance(date_string, datetime):
            return date_string

        # Try multiple date formats
        formats = [
            "%Y-%m-%dT%H:%M:%S",  # ISO format with time
            "%Y-%m-%d",  # ISO date
            "%d/%m/%Y",  # European date
            "%Y-%m-%d %H:%M:%S",  # ISO datetime
        ]

        for fmt in formats:
            try:
                # Handle possible milliseconds in ISO format
                if isinstance(date_string, str) and "." in date_string:
                    date_string = date_string.split(".")[0]
                return datetime.strptime(date_string, fmt)
            except (ValueError, AttributeError):
                continue

        # If we get here, none of the formats worked
        raise ValueError(f"Could not parse date: {date_string}")


class DashboardLayout:
    """
    Handles the layout and structure of the dashboard.

    This class is responsible for setting up the layout of the dashboard,
    including the placement of components and styling of the UI.
    """

    def __init__(
        self,
        color_theme: Dict[str, Any],
        min_date: datetime,
        max_date: datetime,
        fonts: Dict[str, str],
        date_format: str,
    ):
        """
        Initialize the dashboard layout.

        Args:
            color_theme: Color theme for the dashboard
            min_date: Minimum date for the date picker
            max_date: Maximum date for the date picker
            fonts: Font configuration
            date_format: Format for date display
        """
        self.color_theme = color_theme
        self.min_date = min_date
        self.max_date = max_date
        self.fonts = fonts
        self.date_format = date_format

    def create_layout(self) -> Any:
        """
        Create the dashboard layout with bold purple headings.

        Returns:
            dbc.Container: Container with dashboard layout
        """
        # Calculate default date range (January 1 of current year to today)
        today = datetime.now()
        end_date = self.max_date
        start_date = datetime(today.year, 1, 1)  # January 1 of current year

        # Make sure start_date is not before the earliest data
        if start_date < self.min_date:
            start_date = self.min_date

        title_font = self.fonts.get("title_font", "Montserrat")
        body_font = self.fonts.get("body_font", "Open Sans")

        # Apply styles directly to components
        body_style = {
            "backgroundColor": self.color_theme["background"],
            "fontFamily": f'"{body_font}", sans-serif',
            "color": self.color_theme.get("text", "#232323"),  # Dark text for body
        }

        heading_style = {
            "fontFamily": f'"{title_font}", sans-serif',
            "fontWeight": "700",  # Make bolder (700 instead of 600)
            "color": self.color_theme.get("headline", "#6C3BCE"),  # Purple for headings
            "marginBottom": "1.5rem",
        }

        tab_style = {
            "backgroundColor": self.color_theme["background"],
            "borderBottom": f"1px solid #E2E8F0",
            "padding": "12px 24px",
            "fontWeight": "600",
            "color": self.color_theme.get(
                "text", "#232323"
            ),  # Dark text for inactive tabs
        }

        active_tab_style = {
            "borderBottom": f"3px solid {self.color_theme.get('headline', '#6C3BCE')}",
            "fontWeight": "700",  # Make active tab bolder
            "color": self.color_theme.get(
                "headline", "#6C3BCE"
            ),  # Purple for active tab
        }

        return dbc.Container(
            [
                html.H1(
                    "Personal Finance Dashboard",
                    className="text-center mt-4 mb-4",
                    style=heading_style,
                ),
                # Rest of the layout remains the same
                dbc.Row(
                    [
                        dbc.Col(
                            [
                                dcc.DatePickerRange(
                                    id="date-range",
                                    min_date_allowed=self.min_date,
                                    max_date_allowed=self.max_date,
                                    start_date=start_date,
                                    end_date=end_date,
                                    display_format=self.date_format,
                                    first_day_of_week=1,  # Start week on Monday
                                    month_format="MMMM YYYY",
                                    style={"backgroundColor": "#ffffff"},
                                )
                            ],
                            width={"size": 6, "offset": 3},
                            className="text-center",
                        )
                    ],
                    className="mb-4",
                ),
                # Income & Expense cards placed above tabs
                html.Div(id="income-expense-cards", className="mb-4 mt-4"),
                # Tabs for different views
                dbc.Tabs(
                    [
                        dbc.Tab(
                            [
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="main-dashboard"),
                                            width=12,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="expense-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="income-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="stacked-expenses"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="stacked-income"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                            ],
                            label="Expenses & Income",
                            tab_id="expenses-tab",
                            style=tab_style,
                            active_tab_style=active_tab_style,
                        ),
                        dbc.Tab(
                            [
                                html.Div(id="savings-cards", className="mb-4 mt-4"),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="savings-overview"), width=8
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="savings-breakdown"), width=4
                                        ),
                                    ],
                                    className="mb-4",
                                ),
                                dcc.Graph(id="savings-allocation"),
                                html.H4(
                                    "Savings Transactions",
                                    className="mt-4 mb-3",
                                    style=heading_style,  # Apply same heading style to subheader
                                ),
                                html.Div(id="savings-table"),
                            ],
                            label="Savings",
                            tab_id="savings-tab",
                            style=tab_style,
                            active_tab_style=active_tab_style,
                        ),
                    ],
                    id="dashboard-tabs",
                    active_tab="expenses-tab",
                    style={"backgroundColor": self.color_theme["background"]},
                ),
            ],
            fluid=True,
            style=body_style,
        )


class ChartStyler:
    """
    Handles styling of charts and visualizations.

    This class is responsible for applying consistent styling to
    all charts in the dashboard.
    """

    def __init__(self, config: DashboardConfig):
        """
        Initialize the chart styler.

        Args:
            config: Dashboard configuration containing styling parameters
        """
        self.config = config

    def apply_styling(self, fig: go.Figure, title: str) -> go.Figure:
        """
        Apply consistent styling with purple titles and dark text for legends.

        Args:
            fig: Plotly figure to style
            title: Title for the figure

        Returns:
            go.Figure: Styled figure
        """
        # Get chart styling parameters from config
        chart_config = self.config.chart_styling

        # Apply consistent styling to the figure
        fig.update_layout(
            title={
                "text": title,
                "font": {
                    "color": self.config.color_theme.get("headline", "#6C3BCE"),
                    "family": self.config.fonts.get("title_font", "Montserrat"),
                    "size": 20,
                    "weight": "bold",  # Make title bold
                },
            },
            plot_bgcolor=self.config.color_theme["background"],
            paper_bgcolor=self.config.color_theme["background"],
            font=dict(
                color=self.config.color_theme.get(
                    "text", "#232323"
                ),  # Dark text for all elements
                family=self.config.fonts.get("body_font", "Open Sans"),
            ),
            yaxis=dict(
                titlefont=dict(color=self.config.color_theme.get("text", "#232323")),
                tickfont=dict(color=self.config.color_theme.get("text", "#232323")),
                gridcolor="rgba(35, 35, 35, 0.05)",  # Lighter gridlines for white background
                # Format y-axis ticks with euro symbol
                tickformat="€%{y:,.2f}",
            ),
            xaxis=dict(
                titlefont=dict(color=self.config.color_theme.get("text", "#232323")),
                tickfont=dict(color=self.config.color_theme.get("text", "#232323")),
                gridcolor="rgba(35, 35, 35, 0.05)",  # Lighter gridlines for white background
            ),
            legend=dict(
                orientation=chart_config.get("legend_orientation", "h"),
                yanchor=chart_config.get("legend_yanchor", "bottom"),
                y=chart_config.get("legend_y", -0.2),
                xanchor=chart_config.get("legend_xanchor", "center"),
                x=chart_config.get("legend_x", 0.5),
                bgcolor=self.config.color_theme.get("background", "#FFFFFF"),
                font=dict(
                    color=self.config.color_theme.get("text", "#232323")
                ),  # Dark text for legend
                bordercolor="#E2E8F0",  # Subtle border
                borderwidth=1,
            ),
            margin=dict(
                l=chart_config.get("margin_left", 50),
                r=chart_config.get("margin_right", 50),
                t=chart_config.get("margin_top", 60),
                b=chart_config.get("margin_bottom", 80),
            ),
            hoverlabel=dict(
                bgcolor="white",
                font_size=chart_config.get("hover_font_size", 14),
                font_family=chart_config.get("hover_font_family", "Open Sans"),
                font=dict(
                    color=self.config.color_theme.get("text", "#232323")
                ),  # Dark text for hover labels
            ),
        )

        # Set hover templates for different types of traces
        for trace in fig.data:
            if trace.type == "bar":
                trace.hovertemplate = "%{x}<br>%{y:,.2f} €<extra></extra>"
            elif trace.type == "scatter":
                trace.hovertemplate = "%{x}<br>%{y:,.2f} €<extra></extra>"
            elif trace.type == "pie":
                trace.hovertemplate = (
                    "%{label}<br>%{value:,.2f} € (%{percent})<extra></extra>"
                )

        return fig


class ChartFactory:
    """
    Factory for creating different types of charts and visualizations.

    This class is responsible for generating all chart components
    for the dashboard using the provided datasets.
    """

    def __init__(self, color_theme: Dict[str, Any], chart_styler: ChartStyler):
        """
        Initialize the chart factory.

        Args:
            color_theme: Color theme for the charts
            chart_styler: Chart styler instance for consistent styling
        """
        self.color_theme = color_theme
        self.chart_styler = chart_styler

    def create_savings_table(self, df_savings: Optional[pl.DataFrame]) -> Any:
        """
        Create a table of savings transactions.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period."
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value")
                .map_elements(lambda x: f"€{x:.2f}", return_dtype=pl.Utf8)
                .alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
            },
            style_header={
                "backgroundColor": "rgb(230, 230, 230)",
                "fontWeight": "bold",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{Type} = "Allocation"'},
                    "backgroundColor": "rgba(230, 126, 34, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Transfer"'},
                    "backgroundColor": "rgba(39, 174, 96, 0.2)",
                },
                {
                    "if": {"filter_query": '{Type} = "Payment"'},
                    "backgroundColor": "rgba(231, 76, 60, 0.2)",
                },
            ],
            page_size=10,
        )

        return table

    def create_monthly_overview(
        self, df_monthly_summary: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a monthly overview figure with income, expenses, and better blue balance.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                        font=dict(color=self.color_theme.get("text", "#232323")),
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add income bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Income"],
                name="Income",
                marker_color=self.color_theme["income"],
                marker_line_color=self.color_theme["income"],
                marker_line_width=1.5,
                opacity=0.9,
            )
        )

        # Add expense bars
        fig.add_trace(
            go.Bar(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=self.color_theme["expense"],
                marker_line_color=self.color_theme["expense"],
                marker_line_width=1.5,
                opacity=0.9,
            )
        )

        # Add balance line with new blue color
        fig.add_trace(
            go.Scatter(
                x=df_monthly_summary["Month"],
                y=df_monthly_summary["Balance"],
                name="Balance",
                line=dict(color=self.color_theme["balance"], width=3),
                mode="lines+markers",
                marker=dict(size=8, color=self.color_theme["balance"]),
            )
        )

        fig = self.chart_styler.apply_styling(
            fig, "Monthly Income, Expenses, and Balance Overview"
        )
        fig.update_layout(
            barmode="group",
            yaxis=dict(title="Amount (€)"),
            hovermode="x",
        )

        return fig

    def create_category_donut(
        self, df_categories: Optional[pl.DataFrame], title: str, is_income: bool = False
    ) -> go.Figure:
        """
        Create a donut chart for expense or income categories.

        Args:
            df_categories: DataFrame with category data
            title: Chart title
            is_income: Whether this is an income chart (affects colors)

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_categories is None or len(df_categories) == 0:
            fig = go.Figure()
            fig.update_layout(
                title=f"{title} - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text=f"No {title.lower()} data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a donut chart for categories
        labels = df_categories["Category"].to_list()
        values = df_categories["Total"].to_list()

        # Use different parts of the color palette for expenses vs income
        if is_income:
            colors = self.color_theme["categories"][8 : 8 + len(labels)]
        else:
            colors = self.color_theme["categories"][: len(labels)]

        # Ensure we have enough colors
        if len(colors) < len(labels):
            colors = colors * (len(labels) // len(colors) + 1)

        fig = go.Figure(
            data=[
                go.Pie(
                    labels=labels,
                    values=values,
                    hole=0.6,  # Set a larger hole for an elegant donut
                    textinfo="label+percent",
                    marker=dict(colors=colors),
                    textposition="outside",
                    textfont=dict(size=12),
                )
            ]
        )

        fig = self.chart_styler.apply_styling(fig, title)

        return fig

    def create_stacked_bar(
        self,
        df_stacked: Optional[pl.DataFrame],
        title: str,
        value_column: str,
        is_income: bool = False,
    ) -> go.Figure:
        """
        Create a stacked bar chart for expenses or income by category.

        Args:
            df_stacked: DataFrame with stacked data
            title: Chart title
            value_column: Column containing the values
            is_income: Whether this is an income chart (affects colors)

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_stacked is None or len(df_stacked) == 0:
            fig = go.Figure()
            fig = self.chart_styler.apply_styling(fig, f"{title} - No Data Available")
            fig.update_layout(
                yaxis=dict(title="Amount (€)"),
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_stacked["Category"].unique().to_list()

        # Use different parts of the color palette for expenses vs income
        if is_income:
            colors = self.color_theme["categories"][8 : 8 + len(unique_categories)]
        else:
            colors = self.color_theme["categories"][: len(unique_categories)]

        # Ensure we have enough colors
        if len(colors) < len(unique_categories):
            colors = colors * (len(unique_categories) // len(colors) + 1)

        fig = go.Figure()

        # Get all months for consistent x-axis
        all_months = sorted(df_stacked["Month"].unique().to_list())

        for category, color in zip(unique_categories, colors):
            filtered = df_stacked.filter(pl.col("Category") == category)

            # Create a dict for easy month lookup
            values_by_month = {
                row["Month"]: row[value_column] for row in filtered.rows(named=True)
            }

            # Create y-values for all months (with 0 for missing months)
            y_values = [values_by_month.get(month, 0) for month in all_months]

            fig.add_trace(
                go.Bar(
                    x=all_months,
                    y=y_values,
                    name=category,
                    marker_color=color,
                    hovertemplate="%{x}<br>%{y:,.2f} €<extra></extra>",
                )
            )

        fig = self.chart_styler.apply_styling(fig, title)
        fig.update_layout(
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            hovermode="x unified",
        )

        return fig

    def create_savings_overview(
        self, df_savings_metrics: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a savings overview line chart.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add total savings line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSavings"].to_list(),
                name="Total Savings",
                line=dict(color=self.color_theme["savings"]["total"], width=4),
            )
        )

        # Add total allocations line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalAllocated"].to_list(),
                name="Total Allocations",
                line=dict(
                    color=self.color_theme["savings"]["allocation"],
                    width=3,
                    dash="dash",
                ),
            )
        )

        # Add total spent line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSpent"].to_list(),
                name="Total Spent",
                line=dict(
                    color=self.color_theme["savings"]["spent"], width=3, dash="dot"
                ),
            )
        )

        fig = self.chart_styler.apply_styling(fig, "Savings Overview")
        fig.update_layout(
            yaxis=dict(title="Amount (€)"),
            hovermode="x",
            legend=dict(
                orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
            ),
        )

        return fig

    def create_savings_breakdown(
        self, df_savings_by_category: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a pie chart showing the breakdown of savings by category.

        Args:
            df_savings_by_category: DataFrame with savings by category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_by_category is None or len(df_savings_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Breakdown - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Extract categories and values for the pie chart
        categories = df_savings_by_category["Category"].to_list()
        values = df_savings_by_category["Value"].to_list()

        # Create the pie chart
        fig = go.Figure()
        fig.add_trace(
            go.Pie(
                labels=categories,
                values=values,
                hole=0.3,
                textinfo="label+percent",
                insidetextorientation="radial",
            )
        )

        fig = self.chart_styler.apply_styling(
            fig, "Savings Breakdown by Category (Risparmio Only)"
        )

        return fig

    def create_savings_allocation(
        self, df_savings_allocation: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a grouped bar chart comparing allocated vs spent savings.

        Args:
            df_savings_allocation: DataFrame with savings allocation data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_allocation is None or len(df_savings_allocation) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Allocation Status - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Get unique categories and types for plotting
        plot_categories = df_savings_allocation["Category"].unique().to_list()
        plot_types = df_savings_allocation["Type"].unique().to_list()

        # Build a figure with grouped bars
        fig = go.Figure()

        # Colors for different types
        colors = {
            "Saved": self.color_theme["income"],
            "Allocated": self.color_theme["savings"]["allocation"],
            "Spent from Savings": self.color_theme["expense"],
            "Spent from Allocations": "#FFA07A",  # Light salmon color
        }

        for allocation_type in plot_types:
            filtered_data = df_savings_allocation.filter(
                pl.col("Type") == allocation_type
            )

            # Create a dict of values by category
            values_by_category = {}
            for category in plot_categories:
                match = filtered_data.filter(pl.col("Category") == category)
                values_by_category[category] = (
                    match["Value"][0] if len(match) > 0 else 0
                )

            # Add bar trace
            fig.add_trace(
                go.Bar(
                    name=allocation_type,
                    x=list(values_by_category.keys()),
                    y=list(values_by_category.values()),
                    marker_color=colors.get(
                        allocation_type, "#808080"
                    ),  # Default gray if type not found
                )
            )

            fig = self.chart_styler.apply_styling(fig, "Allocation Status by Category")
            fig.update_layout(
                yaxis=dict(title="Amount (€)"),
                barmode="group",
                legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99),
            )

            return fig


class FinanceDashboard:
    """
    A class for creating an interactive financial dashboard.

    This class focuses solely on visualization using pre-processed datasets
    generated by the Process class. It does not perform data processing
    operations itself. The class orchestrates all dashboard components
    and manages the interactions between them.

    Attributes:
        config: Configuration object containing paths to datasets
        logger: Logger instance from the main application
        app: Dash application instance
    """

    def __init__(self, config: "Config", logger: logging.Logger):
        """
        Initialize the FinanceDashboard with configuration and logger.

        Args:
            config: Configuration object containing paths to datasets
            logger: Logger instance from the main application
        """
        self.config = config
        self.logger = logger.getChild("FinanceDashboard")
        self.logger.info("FinanceDashboard initialized")

        # Load configuration for dashboard
        fonts = self.config.get(
            "fonts",
            {
                "title_font": "Montserrat",
                "body_font": "Open Sans",
                "font_url": "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
            },
        )

        # Create dashboard configuration
        dashboard_config = DashboardConfig(
            color_theme=self.config.get("color_palette", {}),
            chart_styling=self.config.get("chart_styling", {}),
            fonts=fonts,
            date_display_format=self.config.get("date_display_format", "DD/MM/YYYY"),
        )

        # Initialize the Dash app with external stylesheets
        self.app = dash.Dash(
            __name__,
            external_stylesheets=[
                dbc.themes.BOOTSTRAP,
                "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css",
                fonts.get(
                    "font_url",
                    "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
                ),
            ],
        )

        # Initialize components
        self.dataset_loader = DatasetLoader(config, logger)
        self.chart_styler = ChartStyler(dashboard_config)
        self.card_creator = CardCreator(dashboard_config.color_theme)
        self.chart_factory = ChartFactory(
            dashboard_config.color_theme, self.chart_styler
        )

        # Load the datasets
        self.dataset_loader.load_all_datasets()

        # Create the layout
        dashboard_layout = DashboardLayout(
            dashboard_config.color_theme,
            self.dataset_loader.min_date,
            self.dataset_loader.max_date,
            dashboard_config.fonts,
            dashboard_config.date_display_format,
        )
        self.app.layout = dashboard_layout.create_layout()

        # Set up the callbacks
        self._setup_callbacks()

    def _setup_callbacks(self) -> None:
        """Set up the dashboard callbacks to respond to user interactions."""

        @self.app.callback(
            [
                Output("income-expense-cards", "children"),
                Output("main-dashboard", "figure"),
                Output("expense-pie-chart", "figure"),
                Output("income-pie-chart", "figure"),
                Output("stacked-expenses", "figure"),
                Output("stacked-income", "figure"),
                Output("savings-cards", "children"),
                Output("savings-overview", "figure"),
                Output("savings-breakdown", "figure"),
                Output("savings-allocation", "figure"),
                Output("savings-table", "children"),
            ],
            [Input("date-range", "start_date"), Input("date-range", "end_date")],
        )
        def update_dashboard(start_date: str, end_date: str) -> Tuple[Any, ...]:
            """
            Update all dashboard components based on the selected date range.

            This function is called whenever the date range picker values change.
            It filters all datasets based on the selected date range and updates
            all visualization components accordingly.

            Args:
                start_date: Start date as string
                end_date: End date as string

            Returns:
                Tuple containing all dashboard components in the order of the Output callbacks
            """
            # Parse dates
            try:
                parsed_start_date = DateParser.parse_date(start_date)
                parsed_end_date = DateParser.parse_date(end_date)
            except ValueError as e:
                self.logger.error(f"Error parsing dates: {str(e)}")
                # Use default dates in case of error
                parsed_start_date = self.dataset_loader.min_date
                parsed_end_date = self.dataset_loader.max_date

            # Convert to month format for filtering monthly data
            start_month = parsed_start_date.strftime("%Y-%m")
            end_month = parsed_end_date.strftime("%Y-%m")

            # Filter datasets by date range
            filtered_monthly_summary = self.dataset_loader.filter_monthly_dataset(
                "monthly_summary_path", start_month, end_month
            )
            filtered_expenses_stacked = self.dataset_loader.filter_monthly_dataset(
                "expenses_stacked_path", start_month, end_month
            )
            filtered_income_stacked = self.dataset_loader.filter_monthly_dataset(
                "income_stacked_path", start_month, end_month
            )
            filtered_savings_metrics = self.dataset_loader.filter_monthly_dataset(
                "savings_metrics_path", start_month, end_month
            )

            # Filter daily datasets
            filtered_processed_savings = self.dataset_loader.filter_daily_dataset(
                "processed_savings_path", parsed_start_date, parsed_end_date
            )

            # Create dashboard elements
            summary_cards = self.card_creator.create_summary_cards(
                filtered_monthly_summary
            )
            fig_main_overview = self.chart_factory.create_monthly_overview(
                filtered_monthly_summary
            )

            # Create category visualizations using original datasets for complete picture
            fig_expense_pie_chart = self.chart_factory.create_category_donut(
                self.dataset_loader.get_dataset("expenses_by_category"),
                "Expense Breakdown by Category",
            )
            fig_income_pie_chart = self.chart_factory.create_category_donut(
                self.dataset_loader.get_dataset("income_by_category"),
                "Income Breakdown by Category",
                is_income=True,
            )

            # Create stacked charts for time series
            fig_stacked_expenses = self.chart_factory.create_stacked_bar(
                filtered_expenses_stacked, "Monthly Expense Breakdown", "Expenses"
            )
            fig_stacked_income = self.chart_factory.create_stacked_bar(
                filtered_income_stacked,
                "Monthly Income Breakdown",
                "Income",
                is_income=True,
            )

            # Create savings elements
            savings_cards = self.card_creator.create_savings_cards(
                filtered_savings_metrics
            )
            fig_savings = self.chart_factory.create_savings_overview(
                filtered_savings_metrics
            )
            fig_savings_breakdown = self.chart_factory.create_savings_breakdown(
                self.dataset_loader.get_dataset("savings_by_category")
            )
            fig_savings_allocation = self.chart_factory.create_savings_allocation(
                self.dataset_loader.get_dataset("savings_allocation")
            )
            savings_table = self.chart_factory.create_savings_table(
                filtered_processed_savings
            )

            return (
                summary_cards,
                fig_main_overview,
                fig_expense_pie_chart,
                fig_income_pie_chart,
                fig_stacked_expenses,
                fig_stacked_income,
                savings_cards,
                fig_savings,
                fig_savings_breakdown,
                fig_savings_allocation,
                savings_table,
            )

    def run_server(self, debug: bool = False, port: int = 8050) -> None:
        """
        Run the Dash server.

        Args:
            debug: Enable debug mode
            port: Port to run the server on
        """
        self.logger.info(f"Dashboard will run at http://127.0.0.1:{port}/")
        self.app.run(debug=debug, port=port)
