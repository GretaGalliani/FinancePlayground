#!/filepath: src/finance_dashboard.py
"""
FinanceDashboard module for visualizing financial data.

This module is responsible for creating an interactive dashboard to visualize
financial data. It focuses solely on visualization and uses pre-processed
datasets generated by the Process class.
"""

import calendar
import logging
import os
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, Union, cast

import dash
import dash_bootstrap_components as dbc
import plotly.graph_objects as go
import polars as pl
from dash import Input, Output, dash_table, dcc, html

from category_mapper import CategoryMapper

if TYPE_CHECKING:
    from config import Config


@dataclass
class DashboardConfig:
    """Configuration container for the dashboard."""

    color_theme: Dict[str, Any]
    chart_styling: Dict[str, Any] = field(default_factory=dict)
    fonts: Dict[str, str] = field(default_factory=dict)
    date_display_format: str = "DD/MM/YYYY"


class DatasetLoader:
    """
    Handles loading and filtering datasets for the dashboard.

    This class is responsible for loading CSV files specified in configuration
    and providing filtered views of the data based on date ranges.
    """

    def __init__(self, config: Any, logger: logging.Logger):
        """
        Initialize the dataset loader.

        Args:
            config: Configuration object containing file paths
            logger: Logger instance for logging data operations
        """
        self.config = config
        self.logger = logger.getChild("DatasetLoader")
        self.datasets: Dict[str, Optional[pl.DataFrame]] = {}
        self.min_date: datetime = datetime.now()
        self.max_date: datetime = datetime.now()
        self.min_month: str = ""
        self.max_month: str = ""

    def load_all_datasets(self) -> None:
        """Load all datasets required for visualization and determine date range."""
        # Load monthly summary data
        self.datasets["monthly_summary"] = self._load_csv("monthly_summary_path")

        # Load expense and income breakdowns
        self.datasets["expenses_by_category"] = self._load_csv(
            "expenses_by_category_path"
        )
        self.datasets["expenses_stacked"] = self._load_csv("expenses_stacked_path")
        self.datasets["income_by_category"] = self._load_csv("income_by_category_path")
        self.datasets["income_stacked"] = self._load_csv("income_stacked_path")

        # Load savings data
        self.datasets["savings_metrics"] = self._load_csv("savings_metrics_path")
        self.datasets["savings_by_category"] = self._load_csv(
            "savings_by_category_path"
        )
        self.datasets["savings_allocation"] = self._load_csv("savings_allocation_path")
        self.datasets["processed_savings"] = self._load_csv("processed_savings_path")

        # Determine date range
        self._determine_date_range()

    def _load_csv(self, config_key: str) -> Optional[pl.DataFrame]:
        """
        Load a CSV file specified in the configuration.

        Args:
            config_key: Key in the configuration for the file path

        Returns:
            pl.DataFrame or None: DataFrame if the file exists, None otherwise
        """
        path = self.config.get(config_key)
        if not path or not os.path.exists(path):
            return None

        try:
            return pl.read_csv(path)
        except Exception as e:
            self.logger.error(f"Error loading {path}: {str(e)}")
            return None

    def _determine_date_range(self) -> None:
        """Determine the min and max dates from the loaded data."""
        monthly_summary = self.datasets["monthly_summary"]

        if monthly_summary is not None and len(monthly_summary) > 0:
            self.min_month = monthly_summary["Month"].min()
            self.max_month = monthly_summary["Month"].max()

            # Convert to date objects for the date picker
            self.min_date = datetime.strptime(f"{self.min_month}-01", "%Y-%m-%d")
            self.max_date = datetime.strptime(f"{self.max_month}-01", "%Y-%m-%d")
            # Add a month to the max date to include the full month
            self.max_date = (self.max_date.replace(day=28) + timedelta(days=4)).replace(
                day=1
            ) - timedelta(days=1)
        else:
            # Default to current month if no data
            today = datetime.now()
            self.min_date = today.replace(day=1) - timedelta(days=180)  # 6 months ago
            self.max_date = today
            self.min_month = self.min_date.strftime("%Y-%m")
            self.max_month = self.max_date.strftime("%Y-%m")

    def filter_monthly_dataset(
        self, config_key: str, start_month: str, end_month: str
    ) -> Optional[pl.DataFrame]:
        """
        Filter a dataset by month range.

        Args:
            config_key: Key in the configuration for the file path
            start_month: Start month in 'YYYY-MM' format
            end_month: End month in 'YYYY-MM' format

        Returns:
            pl.DataFrame or None: Filtered DataFrame
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Month" not in df.columns:
            return df

        return df.filter(
            (pl.col("Month") >= start_month) & (pl.col("Month") <= end_month)
        )

    def filter_daily_dataset(
        self, config_key: str, start_date: datetime, end_date: datetime
    ) -> Optional[pl.DataFrame]:
        """
        Filter a dataset by date range.

        Args:
            config_key: Key in the configuration for the file path
            start_date: Start date
            end_date: End date

        Returns:
            pl.DataFrame or None: Filtered DataFrame
        """
        df = self._load_csv(config_key)
        if df is None or len(df) == 0 or "Date" not in df.columns:
            return df

        # Convert string dates to datetime if needed
        if df["Date"].dtype == pl.Utf8:
            df = df.with_columns(pl.col("Date").str.to_datetime().alias("Date"))

        return df.filter((pl.col("Date") >= start_date) & (pl.col("Date") <= end_date))

    def get_dataset(self, name: str) -> Optional[pl.DataFrame]:
        """
        Get a loaded dataset by name.

        Args:
            name: Name of the dataset

        Returns:
            pl.DataFrame or None: The requested dataset
        """
        return self.datasets.get(name)


class CardCreator:
    """
    Creates summary cards for the dashboard.

    This class is responsible for generating summary cards for income,
    expenses, balance, and savings metrics.
    """

    def __init__(self, color_theme: Dict[str, Any]):
        """
        Initialize the card creator.

        Args:
            color_theme: Color theme for the cards
        """
        self.color_theme = color_theme

    def create_summary_cards(self, df_monthly_summary: Optional[pl.DataFrame]) -> Any:
        """
        Create summary cards for income, expenses, and balance with improved formatting.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            return html.Div(
                "No data available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        total_income = df_monthly_summary["Income"].sum()
        total_expenses = df_monthly_summary["Expenses"].sum()
        total_balance = total_income - total_expenses

        months_count = len(df_monthly_summary)
        monthly_avg_income = total_income / months_count if months_count > 0 else 0
        monthly_avg_expenses = total_expenses / months_count if months_count > 0 else 0
        monthly_avg_balance = total_balance / months_count if months_count > 0 else 0

        # Format numbers with thousands separator (,) and decimal point (.)
        def format_currency(value):
            return f"{value:,.2f}€"

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Income", className="card-title"),
                                html.H3(
                                    format_currency(total_income),
                                    className="card-text font-weight-bold",
                                    style={"color": self.color_theme["income"]},
                                ),
                                html.P(
                                    f"Monthly average: {format_currency(monthly_avg_income)}",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["income"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Expenses", className="card-title"),
                                html.H3(
                                    format_currency(total_expenses),
                                    className="card-text font-weight-bold",
                                    style={"color": self.color_theme["expense"]},
                                ),
                                html.P(
                                    f"Monthly average: {format_currency(monthly_avg_expenses)}",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["expense"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Balance", className="card-title"),
                                html.H3(
                                    format_currency(total_balance),
                                    className="card-text font-weight-bold",
                                    style={"color": self.color_theme["balance"]},
                                ),
                                html.P(
                                    f"Monthly average: {format_currency(monthly_avg_balance)}",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["balance"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    def create_savings_cards(self, df_savings_metrics: Optional[pl.DataFrame]) -> Any:
        """
        Create summary cards for savings data.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            dbc.Row: Row of cards for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            return html.Div(
                "No savings data available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        # Get the latest month's metrics
        latest_month = df_savings_metrics["Month"].max()
        latest_metrics = df_savings_metrics.filter(pl.col("Month") == latest_month)

        if len(latest_metrics) == 0:
            return html.Div(
                "No savings metrics available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        total_savings = latest_metrics["TotalSavings"][0]
        total_allocated = latest_metrics["TotalAllocated"][0]
        total_spent = latest_metrics["TotalSpent"][0]

        cards = dbc.Row(
            [
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Total Savings (€)", className="card-title"),
                                html.H4(
                                    f"{total_savings:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["total"]
                                    },
                                ),
                                html.P(
                                    f"As of {latest_month}",
                                    className="text-muted small",
                                ),
                                html.P(
                                    "All 'Risparmio' type categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["total"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Allocated Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_allocated:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"][
                                            "allocation"
                                        ]
                                    },
                                ),
                                html.P(
                                    "All 'Accantonamento' type categories (additions minus withdrawals)",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["allocation"],
                        },
                    ),
                    width=4,
                ),
                dbc.Col(
                    dbc.Card(
                        dbc.CardBody(
                            [
                                html.H5("Spent Funds (€)", className="card-title"),
                                html.H4(
                                    f"{total_spent:.2f}",
                                    className="card-text",
                                    style={
                                        "color": self.color_theme["savings"]["spent"]
                                    },
                                ),
                                html.P(
                                    "Withdrawals from non-Accantonamento categories",
                                    className="text-muted small",
                                ),
                            ]
                        ),
                        className="shadow-sm",
                        style={
                            "background-color": "#fffffe",
                            "border-color": self.color_theme["savings"]["spent"],
                        },
                    ),
                    width=4,
                ),
            ],
            className="mb-4",
        )

        return cards

    def create_savings_table(self, df_savings: Optional[pl.DataFrame]) -> Any:
        """
        Create a table of savings transactions with white background.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period.",
                style={"color": self.color_theme.get("headline", "#6C3BCE")},
                className="text-center p-4",
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value")
                .map_elements(lambda x: f"€{x:.2f}", return_dtype=pl.Utf8)
                .alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table with white background and purple accents
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
                "backgroundColor": "white",
            },
            style_header={
                "backgroundColor": "rgba(108, 59, 206, 0.1)",  # Light purple background
                "fontWeight": "bold",
                "color": self.color_theme.get("headline", "#6C3BCE"),
                "borderBottom": f"2px solid {self.color_theme.get('headline', '#6C3BCE')}",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{CategoryType} = "Accantonamento"'},
                    "backgroundColor": "rgba(7, 128, 128, 0.05)",  # Very light teal
                    "borderLeft": f"3px solid {self.color_theme['income']}",
                },
                {
                    "if": {"filter_query": "{Value} < 0"},
                    "backgroundColor": "rgba(244, 93, 72, 0.05)",  # Very light coral
                    "borderLeft": f"3px solid {self.color_theme['expense']}",
                },
            ],
            page_size=10,
        )

        return table


class DateParser:
    """
    Handles parsing and standardization of dates in various formats.

    This class provides utilities for parsing dates from strings in
    multiple formats and handling edge cases.
    """

    @staticmethod
    def parse_date(date_string: Union[str, datetime]) -> datetime:
        """
        Parse date string in multiple formats to handle different possible inputs.

        Args:
            date_string: String or datetime representation of date to parse

        Returns:
            datetime: Parsed datetime object

        Raises:
            ValueError: If the date cannot be parsed
        """
        if isinstance(date_string, datetime):
            return date_string

        # Try multiple date formats
        formats = [
            "%Y-%m-%dT%H:%M:%S",  # ISO format with time
            "%Y-%m-%d",  # ISO date
            "%d/%m/%Y",  # European date
            "%Y-%m-%d %H:%M:%S",  # ISO datetime
        ]

        for fmt in formats:
            try:
                # Handle possible milliseconds in ISO format
                if isinstance(date_string, str) and "." in date_string:
                    date_string = date_string.split(".")[0]
                return datetime.strptime(date_string, fmt)
            except (ValueError, AttributeError):
                continue

        # If we get here, none of the formats worked
        raise ValueError(f"Could not parse date: {date_string}")


class DashboardLayout:
    """
    Handles the layout and structure of the dashboard.

    This class is responsible for setting up the layout of the dashboard,
    including the placement of components and styling of the UI.
    """

    def __init__(
        self,
        color_theme: Dict[str, Any],
        min_date: datetime,
        max_date: datetime,
        fonts: Dict[str, str],
        date_format: str,
    ):
        """
        Initialize the dashboard layout.

        Args:
            color_theme: Color theme for the dashboard
            min_date: Minimum date for the date picker
            max_date: Maximum date for the date picker
            fonts: Font configuration
            date_format: Format for date display
        """
        self.color_theme = color_theme
        self.min_date = min_date
        self.max_date = max_date
        self.fonts = fonts
        self.date_format = date_format

    def create_layout(self) -> Any:
        """
        Create the dashboard layout with bold purple headings.

        Returns:
            dbc.Container: Container with dashboard layout
        """
        # Calculate default date range (current month)
        today = datetime.now()
        current_month_start = datetime(today.year, today.month, 1)

        # Set default end date to current month
        end_date = current_month_start

        # Set default start date to 6 months before current month, or min_date if more recent
        start_date = datetime(
            today.year - 1 if today.month < 7 else today.year,
            today.month + 6 if today.month < 7 else today.month - 6,
            1,
        )

        # Make sure dates are within range
        if start_date < self.min_date:
            start_date = self.min_date
        if end_date > self.max_date:
            end_date = datetime(self.max_date.year, self.max_date.month, 1)

        title_font = self.fonts.get("title_font", "Montserrat")
        body_font = self.fonts.get("body_font", "Open Sans")

        # Apply styles directly to components
        body_style = {
            "backgroundColor": self.color_theme["background"],
            "fontFamily": f'"{body_font}", sans-serif',
            "color": self.color_theme.get("text", "#232323"),  # Dark text for body
        }

        heading_style = {
            "fontFamily": f'"{title_font}", sans-serif',
            "fontWeight": "700",  # Make bolder (700 instead of 600)
            "color": self.color_theme.get("headline", "#6C3BCE"),  # Purple for headings
            "marginBottom": "1.5rem",
        }

        tab_style = {
            "backgroundColor": self.color_theme["background"],
            "borderBottom": f"1px solid #E2E8F0",
            "padding": "12px 24px",
            "fontWeight": "600",
            "color": self.color_theme.get(
                "text", "#232323"
            ),  # Dark text for inactive tabs
        }

        active_tab_style = {
            "borderBottom": f"3px solid {self.color_theme.get('headline', '#6C3BCE')}",
            "fontWeight": "700",  # Make active tab bolder
            "color": self.color_theme.get(
                "headline", "#6C3BCE"
            ),  # Purple for active tab
        }

        # Dropdown styles consistent with dashboard design
        dropdown_style = {
            "width": "100%",
            "fontFamily": f'"{body_font}", sans-serif',
            "borderRadius": "4px",
            "boxShadow": "0 1px 3px rgba(0,0,0,0.1)",
        }

        # Label styles
        label_style = {
            "fontFamily": f'"{title_font}", sans-serif',
            "fontWeight": "600",
            "color": self.color_theme.get("headline", "#6C3BCE"),
            "marginBottom": "8px",
            "textAlign": "center",
        }

        # Create dropdown options for month selection in reverse chronological order
        current_date = self.max_date
        month_options = []

        while current_date >= self.min_date:
            # Format as YYYY-MM-01 for internal value and MMM YYYY for display
            first_of_month = datetime(current_date.year, current_date.month, 1)
            month_str = first_of_month.strftime("%Y-%m-%d")
            display_str = first_of_month.strftime("%b %Y")
            month_options.append({"label": display_str, "value": month_str})

            # Move to previous month
            if current_date.month == 1:
                current_date = datetime(current_date.year - 1, 12, 1)
            else:
                current_date = datetime(current_date.year, current_date.month - 1, 1)

        return dbc.Container(
            [
                html.H1(
                    "Personal Finance Dashboard",
                    className="text-center mt-4 mb-4",
                    style=heading_style,
                ),
                # Centered dropdown selectors with consistent styling
                dbc.Row(
                    [
                        dbc.Col(
                            html.Div(
                                [
                                    html.Label("Date Range", style=label_style),
                                    dbc.Row(
                                        [
                                            dbc.Col(
                                                [
                                                    html.Label(
                                                        "From:", className="mr-2 mt-2"
                                                    ),
                                                    dcc.Dropdown(
                                                        id="start-month-dropdown",
                                                        options=month_options,
                                                        value=start_date.strftime(
                                                            "%Y-%m-%d"
                                                        ),
                                                        clearable=False,
                                                        style=dropdown_style,
                                                    ),
                                                ],
                                                width=5,
                                                className="pr-0",
                                            ),
                                            dbc.Col(
                                                html.Div(
                                                    html.I(
                                                        className="fas fa-arrow-right"
                                                    ),
                                                    className="d-flex align-items-center justify-content-center h-100",
                                                    style={"marginTop": "15px"},
                                                ),
                                                width=2,
                                                className="px-0 text-center",
                                            ),
                                            dbc.Col(
                                                [
                                                    html.Label(
                                                        "To:", className="mr-2 mt-2"
                                                    ),
                                                    dcc.Dropdown(
                                                        id="end-month-dropdown",
                                                        options=month_options,
                                                        value=end_date.strftime(
                                                            "%Y-%m-%d"
                                                        ),
                                                        clearable=False,
                                                        style=dropdown_style,
                                                    ),
                                                ],
                                                width=5,
                                                className="pl-0",
                                            ),
                                        ],
                                        className="align-items-end",
                                    ),
                                ],
                                className="p-3 mb-3 shadow-sm rounded",
                                style={
                                    "backgroundColor": "#FFFFFF",
                                    "border": f"1px solid {self.color_theme.get('headline', '#6C3BCE')}",
                                },
                            ),
                            width={"size": 6, "offset": 3},
                            className="text-center",
                        )
                    ],
                    className="mb-4",
                ),
                # Income & Expense cards placed above tabs
                html.Div(id="income-expense-cards", className="mb-4 mt-4"),
                dbc.Tabs(
                    [
                        dbc.Tab(
                            [
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="main-dashboard"),
                                            width=12,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                # REORDERED: Display stacked charts (monthly breakdown) in full rows
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(
                                                id="stacked-expenses",
                                                style={
                                                    "height": "500px"
                                                },  # Taller graph
                                            ),
                                            width=12,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(
                                                id="stacked-income",
                                                style={
                                                    "height": "500px"
                                                },  # Taller graph
                                            ),
                                            width=12,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="expense-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="income-pie-chart"),
                                            width=6,
                                            className="mb-4",
                                        ),
                                    ]
                                ),
                            ],
                            label="Expenses & Income",
                            tab_id="expenses-tab",
                            style=tab_style,
                            active_tab_style=active_tab_style,
                        ),
                        dbc.Tab(
                            [
                                html.Div(id="savings-cards", className="mb-4 mt-4"),
                                dbc.Row(
                                    [
                                        dbc.Col(
                                            dcc.Graph(id="savings-overview"), width=8
                                        ),
                                        dbc.Col(
                                            dcc.Graph(id="savings-breakdown"), width=4
                                        ),
                                    ],
                                    className="mb-4",
                                ),
                                dcc.Graph(id="savings-allocation"),
                                html.H4(
                                    "Savings Transactions",
                                    className="mt-4 mb-3",
                                    style=heading_style,
                                ),
                                html.Div(id="savings-table"),
                            ],
                            label="Savings",
                            tab_id="savings-tab",
                            style=tab_style,
                            active_tab_style=active_tab_style,
                        ),
                    ],
                    id="dashboard-tabs",
                    active_tab="expenses-tab",
                    style={"backgroundColor": self.color_theme["background"]},
                ),
            ],
            fluid=True,
            style=body_style,
        )


class ChartStyler:
    """
    Handles styling of charts and visualizations.

    This class is responsible for applying consistent styling to
    all charts in the dashboard.
    """

    def __init__(self, config: DashboardConfig):
        """
        Initialize the chart styler.

        Args:
            config: Dashboard configuration containing styling parameters
        """
        self.config = config

    def apply_styling(self, fig: go.Figure, title: str) -> go.Figure:
        """
        Apply consistent styling with purple titles and dark text for legends.

        Args:
            fig: Plotly figure to style
            title: Title for the figure

        Returns:
            go.Figure: Styled figure
        """
        # Get chart styling parameters from config
        chart_config = self.config.chart_styling

        # Apply consistent styling to the figure
        fig.update_layout(
            title={
                "text": title,
                "font": {
                    "color": self.config.color_theme.get("headline", "#6C3BCE"),
                    "family": self.config.fonts.get("title_font", "Montserrat"),
                    "size": 20,
                    "weight": "bold",  # Make title bold
                },
            },
            plot_bgcolor=self.config.color_theme["background"],
            paper_bgcolor=self.config.color_theme["background"],
            font=dict(
                color=self.config.color_theme.get(
                    "text", "#232323"
                ),  # Dark text for all elements
                family=self.config.fonts.get("body_font", "Open Sans"),
            ),
            yaxis=dict(
                titlefont=dict(color=self.config.color_theme.get("text", "#232323")),
                tickfont=dict(color=self.config.color_theme.get("text", "#232323")),
                gridcolor="rgba(35, 35, 35, 0.05)",  # Lighter gridlines for white background
                # Format y-axis ticks with euro symbol
                tickformat="€%{y:,.2f}",
            ),
            xaxis=dict(
                titlefont=dict(color=self.config.color_theme.get("text", "#232323")),
                tickfont=dict(color=self.config.color_theme.get("text", "#232323")),
                gridcolor="rgba(35, 35, 35, 0.05)",  # Lighter gridlines for white background
            ),
            legend=dict(
                orientation=chart_config.get("legend_orientation", "h"),
                yanchor=chart_config.get("legend_yanchor", "bottom"),
                y=chart_config.get("legend_y", -0.2),
                xanchor=chart_config.get("legend_xanchor", "center"),
                x=chart_config.get("legend_x", 0.5),
                bgcolor=self.config.color_theme.get("background", "#FFFFFF"),
                font=dict(
                    color=self.config.color_theme.get("text", "#232323")
                ),  # Dark text for legend
                bordercolor="#E2E8F0",  # Subtle border
                borderwidth=1,
            ),
            margin=dict(
                l=chart_config.get("margin_left", 50),
                r=chart_config.get("margin_right", 50),
                t=chart_config.get("margin_top", 60),
                b=chart_config.get("margin_bottom", 80),
            ),
            hoverlabel=dict(
                bgcolor="white",
                font_size=chart_config.get("hover_font_size", 14),
                font_family=chart_config.get("hover_font_family", "Open Sans"),
                font=dict(
                    color=self.config.color_theme.get("text", "#232323")
                ),  # Dark text for hover labels
            ),
            # Use unified hover mode to show date only once at the top
            hovermode="x unified",
        )

        return fig


class ChartFactory:
    """
    Factory for creating different types of charts and visualizations.

    This class is responsible for generating all chart components
    for the dashboard using the provided datasets with consistent category colors.
    """

    def __init__(
        self,
        color_theme: Dict[str, Any],
        chart_styler: Any,
        category_mapper: CategoryMapper,
    ):
        """
        Initialize the chart factory.

        Args:
            color_theme: Color theme for the charts
            chart_styler: Chart styler instance for consistent styling
            category_mapper: CategoryMapper for consistent category colors
        """
        self.color_theme = color_theme
        self.chart_styler = chart_styler
        self.category_mapper = category_mapper
        self.logger = logging.getLogger(__name__)


#!/filepath: src/chart_factory.py
"""
ChartFactory module for creating visualizations in the finance dashboard.

This module is responsible for generating all chart components
for the dashboard using the provided datasets and consistent category colors.
"""

import logging
from typing import Any, Dict, List, Optional

import plotly.graph_objects as go
import polars as pl
from dash import dash_table, html

from category_mapper import CategoryMapper


class ChartFactory:
    """
    Factory for creating different types of charts and visualizations.

    This class is responsible for generating all chart components
    for the dashboard using the provided datasets with consistent category colors.
    """

    def __init__(
        self,
        color_theme: Dict[str, Any],
        chart_styler: Any,
        category_mapper: CategoryMapper,
    ):
        """
        Initialize the chart factory.

        Args:
            color_theme: Color theme for the charts
            chart_styler: Chart styler instance for consistent styling
            category_mapper: CategoryMapper for consistent category colors
        """
        self.color_theme = color_theme
        self.chart_styler = chart_styler
        self.category_mapper = category_mapper
        self.logger = logging.getLogger(__name__)

    def create_category_donut(
        self, df_categories: Optional[pl.DataFrame], title: str, is_income: bool = False
    ) -> go.Figure:
        """
        Create a donut chart for expense or income categories with consistent colors.

        Args:
            df_categories: DataFrame with category data
            title: Chart title
            is_income: Whether this is an income chart (affects colors)

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_categories is None or len(df_categories) == 0:
            fig = go.Figure()
            fig.update_layout(
                title=f"{title} - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text=f"No {title.lower()} data available",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Create a donut chart for categories
        labels = df_categories["Category"].to_list()
        values = df_categories["Total"].to_list()

        # Get consistent colors for the categories
        if is_income:
            colors = self.category_mapper.get_income_colors(labels)
        else:
            colors = self.category_mapper.get_expense_colors(labels)

        # Create custom hover text with formatted values
        hover_texts = []
        for i, (label, value) in enumerate(zip(labels, values)):
            percentage = (value / sum(values) * 100) if sum(values) > 0 else 0
            hover_texts.append(f"{label}: {value:,.2f}€ ({percentage:.1f}%)")

        fig = go.Figure(
            data=[
                go.Pie(
                    labels=labels,
                    values=values,
                    hole=0.6,  # Keep large hole for elegant donut
                    textinfo="label",  # Show only category labels
                    marker=dict(colors=colors),
                    textposition="outside",
                    textfont=dict(size=12),
                    hovertext=hover_texts,
                    hoverinfo="text",
                )
            ]
        )

        # First apply basic styling
        fig = self.chart_styler.apply_styling(fig, title)

        # Then add specific layout for pie charts with external legend
        fig.update_layout(
            # Set a fixed height for both charts to ensure they're the same size
            height=550,
            # Create plenty of space below for the legend
            margin=dict(t=80, b=200, l=5, r=5),
            # Force the legend outside the plot area
            legend=dict(
                orientation="h",
                y=-0.3,  # Position below the plot area
                yanchor="top",
                x=0.5,
                xanchor="center",
                # Make the legend span most of the width
                entrywidth=90,
                # Force it outside
                bordercolor="#E2E8F0",
                borderwidth=1,
            ),
        )

        # Position the text labels to avoid overlap with legend
        fig.update_traces(
            insidetextfont=dict(size=12),
            outsidetextfont=dict(size=12),
        )

        return fig

    def create_stacked_bar(
        self,
        df_stacked: Optional[pl.DataFrame],
        title: str,
        value_column: str,
        is_income: bool = False,
    ) -> go.Figure:
        """
        Create a stacked bar chart with consistent category colors.

        Args:
            df_stacked: DataFrame with stacked data
            title: Chart title
            value_column: Column containing the values
            is_income: Whether this is an income chart (affects colors)

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_stacked is None or len(df_stacked) == 0:
            fig = go.Figure()
            fig = self.chart_styler.apply_styling(fig, f"{title} - No Data Available")
            fig.update_layout(
                yaxis=dict(title="Amount (€)"),
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        unique_categories = df_stacked["Category"].unique().to_list()

        # Get consistent colors for the categories
        if is_income:
            color_map = {
                category: self.category_mapper.get_income_category_color(category)
                for category in unique_categories
            }
        else:
            color_map = {
                category: self.category_mapper.get_expense_category_color(category)
                for category in unique_categories
            }

        # Get all months for consistent x-axis
        all_months = sorted(df_stacked["Month"].unique().to_list())

        # Format months for display
        months = []
        for month_str in all_months:
            year, month = month_str.split("-")
            month_name = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ][int(month) - 1]
            months.append(f"{month_name} {year}")

        # Create monthly data structure and calculate percentages
        monthly_data = {}
        for month_display, month_raw in zip(months, all_months):
            month_df = df_stacked.filter(pl.col("Month") == month_raw)
            total = month_df[value_column].sum()

            # Get category data sorted by value
            cat_data = []
            for category in unique_categories:
                cat_df = month_df.filter(pl.col("Category") == category)
                if len(cat_df) > 0:
                    value = cat_df[value_column].sum()
                    if value > 0:  # Only include categories with values
                        percentage = (value / total * 100) if total > 0 else 0
                        cat_data.append(
                            {
                                "category": category,
                                "value": value,
                                "percentage": percentage,
                                "color": color_map[category],
                            }
                        )

            # Sort by value (largest first)
            cat_data.sort(key=lambda x: x["value"], reverse=True)

            monthly_data[month_display] = {"total": total, "categories": cat_data}

        # Create the figure
        fig = go.Figure()

        # For each category, add a trace to the stacked bar with custom hover text
        for category in unique_categories:
            values = []
            hover_texts = []

            # Create values and hover texts for each month for this category
            for month in months:
                # Get this category's value for the month
                cat_value = 0
                cat_percentage = 0
                month_total = monthly_data[month]["total"]

                for cat in monthly_data[month]["categories"]:
                    if cat["category"] == category:
                        cat_value = cat["value"]
                        cat_percentage = cat["percentage"]
                        break

                values.append(cat_value)

                # Create the hover text for this segment with month total, category value, and percentage
                hover_text = (
                    f"<b>{month}</b><br>"
                    + f"<b>Total:</b> {month_total:,.2f}€<br>"
                    + f"<b>{category}:</b> {cat_value:,.2f}€<br>"
                    + f"<b>Percentage:</b> {cat_percentage:.1f}%"
                )

                hover_texts.append(hover_text)

            # Only add trace if there are values
            if sum(values) > 0:
                fig.add_trace(
                    go.Bar(
                        x=months,
                        y=values,
                        name=category,
                        marker_color=color_map[category],  # Use consistent color
                        hoverinfo="text",
                        hovertext=hover_texts,
                        text=None,
                        textposition="none",  # Don't show text on bars to avoid clutter
                    )
                )

        # Style the figure
        fig = self.chart_styler.apply_styling(fig, title)

        # Set layout properties
        fig.update_layout(
            barmode="stack",
            yaxis=dict(title="Amount (€)"),
            hovermode="closest",  # Use closest mode for best hover behavior
            # Standard legend positioning
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=-0.2,
                xanchor="center",
                x=0.5,
            ),
        )

        return fig

    def create_savings_breakdown(
        self, df_savings_by_category: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a pie chart showing the breakdown of savings by category with consistent colors.

        Args:
            df_savings_by_category: DataFrame with savings by category

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_by_category is None or len(df_savings_by_category) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Breakdown - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Extract categories and values for the pie chart
        categories = df_savings_by_category["Category"].to_list()
        values = df_savings_by_category["Value"].to_list()

        # Get consistent colors for savings categories
        colors = self.category_mapper.get_savings_colors(categories)

        # Create the pie chart
        fig = go.Figure()
        fig.add_trace(
            go.Pie(
                labels=categories,
                values=values,
                hole=0.3,
                textinfo="label+percent",
                insidetextorientation="radial",
                marker=dict(colors=colors),  # Use consistent colors
            )
        )

        fig = self.chart_styler.apply_styling(
            fig, "Savings Breakdown by Category (Risparmio Only)"
        )

        return fig

    def create_savings_allocation(
        self, df_savings_allocation: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a grouped bar chart comparing allocated vs spent savings with consistent colors.

        Args:
            df_savings_allocation: DataFrame with savings allocation data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_allocation is None or len(df_savings_allocation) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Allocation Status - No Data Available",
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        # Get unique categories and types for plotting
        plot_categories = df_savings_allocation["Category"].unique().to_list()
        plot_types = df_savings_allocation["Type"].unique().to_list()

        # Build a figure with grouped bars
        fig = go.Figure()

        # Colors for different types
        colors = {
            "Saved": self.color_theme["income"],
            "Allocated": self.color_theme["savings"]["allocation"],
            "Spent from Savings": self.color_theme["expense"],
            "Spent from Allocations": "#FFA07A",  # Light salmon color
        }

        for allocation_type in plot_types:
            filtered_data = df_savings_allocation.filter(
                pl.col("Type") == allocation_type
            )

            # Create a dict of values by category
            values_by_category = {}
            for category in plot_categories:
                match = filtered_data.filter(pl.col("Category") == category)
                values_by_category[category] = (
                    match["Value"][0] if len(match) > 0 else 0
                )

            # Add bar trace
            fig.add_trace(
                go.Bar(
                    name=allocation_type,
                    x=list(values_by_category.keys()),
                    y=list(values_by_category.values()),
                    marker_color=colors.get(
                        allocation_type, "#808080"
                    ),  # Default gray if type not found
                )
            )

        fig = self.chart_styler.apply_styling(fig, "Allocation Status by Category")
        fig.update_layout(
            yaxis=dict(title="Amount (€)"),
            barmode="group",
            legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99),
        )

        return fig

    def create_monthly_overview(
        self, df_monthly_summary: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a monthly overview figure with larger colored indicators in hover text.

        Args:
            df_monthly_summary: DataFrame with monthly summary data

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_monthly_summary is None or len(df_monthly_summary) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Monthly Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                        font=dict(color=self.color_theme.get("text", "#232323")),
                    )
                ],
            )
            return fig

        # Format month strings for display (from YYYY-MM to MMM YYYY)
        months = []
        for month_str in df_monthly_summary["Month"]:
            year = month_str.split("-")[0]
            month_num = int(month_str.split("-")[1])
            month_name = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ][month_num - 1]
            months.append(f"{month_name} {year}")

        # Create combined data for hover
        combined_data = []
        for i in range(len(months)):
            combined_data.append(
                {
                    "month": months[i],
                    "income": df_monthly_summary["Income"][i],
                    "expenses": df_monthly_summary["Expenses"][i],
                    "balance": df_monthly_summary["Balance"][i],
                }
            )

        # Get color values
        income_color = self.color_theme["income"]
        expense_color = self.color_theme["expense"]
        balance_color = self.color_theme["balance"]

        # Create hover template with colored squares
        hover_template = (
            "<b>%{customdata.month}</b><br>"
            f"<span style='color:{income_color}; font-size:22px;'>■</span> Income: %{{customdata.income:,.2f}}€<br>"
            f"<span style='color:{expense_color}; font-size:22px;'>■</span> Expenses: %{{customdata.expenses:,.2f}}€<br>"
            f"<span style='color:{balance_color}; font-size:22px;'>■</span> Balance: %{{customdata.balance:,.2f}}€"
            "<extra></extra>"
        )

        fig = go.Figure()

        # Add income bars
        fig.add_trace(
            go.Bar(
                x=months,
                y=df_monthly_summary["Income"],
                name="Income",
                marker_color=income_color,
                marker_line_color=income_color,
                marker_line_width=1.5,
                opacity=0.9,
                customdata=combined_data,
                hovertemplate=hover_template,
            )
        )

        # Add expense bars
        fig.add_trace(
            go.Bar(
                x=months,
                y=df_monthly_summary["Expenses"],
                name="Expenses",
                marker_color=expense_color,
                marker_line_color=expense_color,
                marker_line_width=1.5,
                opacity=0.9,
                customdata=combined_data,
                hovertemplate=hover_template,
            )
        )

        # Add balance line
        fig.add_trace(
            go.Scatter(
                x=months,
                y=df_monthly_summary["Balance"],
                name="Balance",
                line=dict(color=balance_color, width=3),
                mode="lines+markers",
                marker=dict(size=8, color=balance_color),
                customdata=combined_data,
                hovertemplate=hover_template,
            )
        )

        fig = self.chart_styler.apply_styling(
            fig, "Monthly Income, Expenses, and Balance Overview"
        )

        fig.update_layout(
            barmode="group",
            yaxis=dict(title="Amount (€)"),
            hovermode="closest",
        )

        return fig

    def create_savings_overview(
        self, df_savings_metrics: Optional[pl.DataFrame]
    ) -> go.Figure:
        """
        Create a savings overview line chart.

        Args:
            df_savings_metrics: DataFrame with savings metrics

        Returns:
            go.Figure: Plotly figure for the dashboard
        """
        if df_savings_metrics is None or len(df_savings_metrics) == 0:
            fig = go.Figure()
            fig.update_layout(
                title="Savings Overview - No Data Available",
                yaxis=dict(title="Amount (€)"),
                plot_bgcolor=self.color_theme["background"],
                annotations=[
                    dict(
                        text="No savings data available for selected period",
                        showarrow=False,
                        xref="paper",
                        yref="paper",
                        x=0.5,
                        y=0.5,
                    )
                ],
            )
            return fig

        fig = go.Figure()

        # Add total savings line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSavings"].to_list(),
                name="Total Savings",
                line=dict(color=self.color_theme["savings"]["total"], width=4),
            )
        )

        # Add total allocations line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalAllocated"].to_list(),
                name="Total Allocations",
                line=dict(
                    color=self.color_theme["savings"]["allocation"],
                    width=3,
                    dash="dash",
                ),
            )
        )

        # Add total spent line
        fig.add_trace(
            go.Scatter(
                x=df_savings_metrics["Month"].to_list(),
                y=df_savings_metrics["TotalSpent"].to_list(),
                name="Total Spent",
                line=dict(
                    color=self.color_theme["savings"]["spent"], width=3, dash="dot"
                ),
            )
        )

        fig = self.chart_styler.apply_styling(fig, "Savings Overview")
        fig.update_layout(
            yaxis=dict(title="Amount (€)"),
            hovermode="x",
            legend=dict(
                orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1
            ),
        )

        return fig

    def create_savings_table(self, df_savings: Optional[pl.DataFrame]) -> Any:
        """
        Create a table of savings transactions.

        Args:
            df_savings: DataFrame with savings transactions

        Returns:
            dash_table.DataTable: DataTable component for the dashboard
        """
        if df_savings is None or len(df_savings) == 0:
            return html.Div(
                "No savings transactions available for the selected period."
            )

        # Create a copy of the dataframe with sorted data
        df_table = df_savings.sort("Date", descending=True)

        # Format date and numeric columns for display
        df_table = df_table.with_columns(
            [
                pl.col("Date").dt.strftime("%d/%m/%Y").alias("Date"),
                pl.col("Value")
                .map_elements(lambda x: f"€{x:.2f}", return_dtype=pl.Utf8)
                .alias("Amount"),
            ]
        )

        # Select and rename columns for display
        df_display = df_table.select(
            ["Date", "Description", "Category", "CategoryType", "Value"]
        )

        # Convert directly to records for Dash without using pandas
        records = df_display.to_dicts()

        # Create the table
        table = dash_table.DataTable(
            data=records,
            columns=[{"name": col, "id": col} for col in df_display.columns],
            style_table={"overflowX": "auto"},
            style_cell={
                "textAlign": "left",
                "padding": "10px",
                "whiteSpace": "normal",
                "height": "auto",
            },
            style_header={
                "backgroundColor": "rgb(230, 230, 230)",
                "fontWeight": "bold",
            },
            style_data_conditional=[
                {
                    "if": {"filter_query": '{CategoryType} = "Accantonamento"'},
                    "backgroundColor": "rgba(7, 128, 128, 0.05)",  # Very light teal
                    "borderLeft": f"3px solid {self.color_theme['income']}",
                },
                {
                    "if": {"filter_query": "{Value} < 0"},
                    "backgroundColor": "rgba(244, 93, 72, 0.05)",  # Very light coral
                    "borderLeft": f"3px solid {self.color_theme['expense']}",
                },
            ],
            page_size=10,
        )

        return table


class FinanceDashboard:
    """
    A class for creating an interactive financial dashboard.
    """

    def __init__(
        self,
        config: "Config",
        logger: logging.Logger,
        category_mapper: Optional[CategoryMapper] = None,
    ):
        """
        Initialize the FinanceDashboard with configuration and logger.

        Args:
            config: Configuration object containing paths to datasets
            logger: Logger instance from the main application
            category_mapper: Optional CategoryMapper for consistent category colors
        """
        self.config = config
        self.logger = logger.getChild("FinanceDashboard")
        self.logger.info("FinanceDashboard initialized")

        # Load configuration for dashboard
        fonts = self.config.get(
            "fonts",
            {
                "title_font": "Montserrat",
                "body_font": "Open Sans",
                "font_url": "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
            },
        )

        # Create dashboard configuration
        dashboard_config = DashboardConfig(
            color_theme=self.config.get("color_palette", {}),
            chart_styling=self.config.get("chart_styling", {}),
            fonts=fonts,
            date_display_format=self.config.get("date_display_format", "DD/MM/YYYY"),
        )

        # Initialize the Dash app with external stylesheets
        self.app = dash.Dash(
            __name__,
            external_stylesheets=[
                dbc.themes.BOOTSTRAP,
                "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css",
                fonts.get(
                    "font_url",
                    "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@400;600&display=swap",
                ),
            ],
        )

        # Initialize components
        self.dataset_loader = DatasetLoader(config, logger)
        self.chart_styler = ChartStyler(dashboard_config)
        self.card_creator = CardCreator(dashboard_config.color_theme)

        # Use provided category mapper or create a new one
        self.category_mapper = category_mapper or CategoryMapper(config, logger)

        # Initialize chart factory with the category mapper
        self.chart_factory = ChartFactory(
            dashboard_config.color_theme, self.chart_styler, self.category_mapper
        )

        # Load the datasets
        self.dataset_loader.load_all_datasets()

        # Create the layout
        dashboard_layout = DashboardLayout(
            dashboard_config.color_theme,
            self.dataset_loader.min_date,
            self.dataset_loader.max_date,
            dashboard_config.fonts,
            dashboard_config.date_display_format,
        )
        self.app.layout = dashboard_layout.create_layout()

        # Set up the callbacks
        self._setup_callbacks()

    def _setup_callbacks(self) -> None:
        """Set up the dashboard callbacks to respond to user interactions."""

        @self.app.callback(
            [
                Output("income-expense-cards", "children"),
                Output("main-dashboard", "figure"),
                Output("expense-pie-chart", "figure"),
                Output("income-pie-chart", "figure"),
                Output("stacked-expenses", "figure"),
                Output("stacked-income", "figure"),
                Output("savings-cards", "children"),
                Output("savings-overview", "figure"),
                Output("savings-breakdown", "figure"),
                Output("savings-allocation", "figure"),
                Output("savings-table", "children"),
            ],
            [
                Input("start-month-dropdown", "value"),
                Input("end-month-dropdown", "value"),
            ],
        )
        def update_dashboard(start_month: str, end_month: str) -> Tuple[Any, ...]:
            """
            Update all dashboard components based on the selected month range.

            Args:
                start_month: Start month as string (YYYY-MM-DD format)
                end_month: End month as string (YYYY-MM-DD format)

            Returns:
                Tuple containing all dashboard components in the order of the Output callbacks
            """
            # Parse dates - each dropdown value contains the first day of the month
            try:
                parsed_start_date = datetime.strptime(start_month, "%Y-%m-%d")
                parsed_end_date = datetime.strptime(end_month, "%Y-%m-%d")

                # For end date, we want the last day of the selected month
                last_day = calendar.monthrange(
                    parsed_end_date.year, parsed_end_date.month
                )[1]
                parsed_end_date = datetime(
                    parsed_end_date.year, parsed_end_date.month, last_day
                )

            except ValueError as e:
                self.logger.error(f"Error parsing dates: {str(e)}")
                # Use default dates in case of error
                parsed_start_date = self.dataset_loader.min_date
                parsed_end_date = self.dataset_loader.max_date

            # Convert to month format for filtering monthly data
            start_month_str = parsed_start_date.strftime("%Y-%m")
            end_month_str = parsed_end_date.strftime("%Y-%m")

            # Filter datasets by date range
            filtered_monthly_summary = self.dataset_loader.filter_monthly_dataset(
                "monthly_summary_path", start_month, end_month
            )
            filtered_expenses_stacked = self.dataset_loader.filter_monthly_dataset(
                "expenses_stacked_path", start_month, end_month
            )
            filtered_income_stacked = self.dataset_loader.filter_monthly_dataset(
                "income_stacked_path", start_month, end_month
            )
            filtered_savings_metrics = self.dataset_loader.filter_monthly_dataset(
                "savings_metrics_path", start_month, end_month
            )

            # Filter daily datasets
            filtered_processed_savings = self.dataset_loader.filter_daily_dataset(
                "processed_savings_path", parsed_start_date, parsed_end_date
            )

            # Create dashboard elements
            summary_cards = self.card_creator.create_summary_cards(
                filtered_monthly_summary
            )
            fig_main_overview = self.chart_factory.create_monthly_overview(
                filtered_monthly_summary
            )

            # Create category visualizations using original datasets for complete picture
            fig_expense_pie_chart = self.chart_factory.create_category_donut(
                self.dataset_loader.get_dataset("expenses_by_category"),
                "Expense Breakdown by Category",
            )
            fig_income_pie_chart = self.chart_factory.create_category_donut(
                self.dataset_loader.get_dataset("income_by_category"),
                "Income Breakdown by Category",
                is_income=True,
            )

            # Create stacked charts for time series
            fig_stacked_expenses = self.chart_factory.create_stacked_bar(
                filtered_expenses_stacked, "Monthly Expense Breakdown", "Expenses"
            )
            fig_stacked_income = self.chart_factory.create_stacked_bar(
                filtered_income_stacked,
                "Monthly Income Breakdown",
                "Income",
                is_income=True,
            )

            # Create savings elements
            savings_cards = self.card_creator.create_savings_cards(
                filtered_savings_metrics
            )
            fig_savings = self.chart_factory.create_savings_overview(
                filtered_savings_metrics
            )
            fig_savings_breakdown = self.chart_factory.create_savings_breakdown(
                self.dataset_loader.get_dataset("savings_by_category")
            )
            fig_savings_allocation = self.chart_factory.create_savings_allocation(
                self.dataset_loader.get_dataset("savings_allocation")
            )
            savings_table = self.chart_factory.create_savings_table(
                filtered_processed_savings
            )

            return (
                summary_cards,
                fig_main_overview,
                fig_expense_pie_chart,
                fig_income_pie_chart,
                fig_stacked_expenses,
                fig_stacked_income,
                savings_cards,
                fig_savings,
                fig_savings_breakdown,
                fig_savings_allocation,
                savings_table,
            )

    def run_server(self, debug: bool = False, port: int = 8050) -> None:
        """
        Run the Dash server.

        Args:
            debug: Enable debug mode
            port: Port to run the server on
        """
        self.logger.info(f"Dashboard will run at http://127.0.0.1:{port}/")
        self.app.run(debug=debug, port=port)
